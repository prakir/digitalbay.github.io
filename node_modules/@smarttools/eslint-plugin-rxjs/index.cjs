"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// packages/eslint-plugin-rxjs/src/lib/configs/recommended.ts
var require_recommended = __commonJS({
  "packages/eslint-plugin-rxjs/src/lib/configs/recommended.ts"(exports2, module2) {
    "use strict";
    module2.exports = {
      plugins: ["@smarttools/rxjs"],
      rules: {
        "@smarttools/rxjs/no-async-subscribe": "error",
        "@smarttools/rxjs/no-create": "error",
        "@smarttools/rxjs/no-ignored-notifier": "error",
        "@smarttools/rxjs/no-ignored-replay-buffer": "error",
        "@smarttools/rxjs/no-ignored-takewhile-value": "error",
        "@smarttools/rxjs/no-implicit-any-catch": "error",
        "@smarttools/rxjs/no-index": "error",
        "@smarttools/rxjs/no-internal": "error",
        "@smarttools/rxjs/no-nested-subscribe": "error",
        "@smarttools/rxjs/no-redundant-notify": "error",
        "@smarttools/rxjs/no-sharereplay": ["error", { allowConfig: true }],
        "@smarttools/rxjs/no-subject-unsubscribe": "error",
        "@smarttools/rxjs/no-unbound-methods": "error",
        "@smarttools/rxjs/no-unsafe-subject-next": "error",
        "@smarttools/rxjs/no-unsafe-takeuntil": "error"
      }
    };
  }
});

// packages/eslint-plugin-rxjs/package.json
var require_package = __commonJS({
  "packages/eslint-plugin-rxjs/package.json"(exports2, module2) {
    module2.exports = {
      name: "@smarttools/eslint-plugin-rxjs",
      version: "1.0.22",
      dependencies: {
        "@typescript-eslint/utils": "^8.33.1",
        "ts-api-utils": "^2.1.0"
      },
      peerDependencies: {
        typescript: ">=4.0.0"
      },
      repository: {
        type: "git",
        url: "https://github.com/DaveMBush/eslint-plugin-rxjs"
      },
      keywords: [
        "eslint",
        "eslintplugin",
        "eslint-plugin",
        "rxjs"
      ],
      publishConfig: {
        access: "public"
      },
      license: "MIT",
      type: "commonjs",
      main: "./index.cjs",
      types: "./index.d.ts",
      exports: {
        ".": {
          require: "./index.cjs",
          types: "./index.d.ts",
          import: "./index.cjs"
        }
      }
    };
  }
});

// packages/eslint-plugin-rxjs/src/index.ts
var import_recommended = __toESM(require_recommended());

// packages/eslint-plugin-rxjs/src/lib/rules/ban-observables.ts
var import_utils = require("@typescript-eslint/utils");
var import_utils2 = require("@typescript-eslint/utils");
var defaultOptions = [];
var messageId = "forbidden";
var ban_observables_default = import_utils2.ESLintUtils.RuleCreator(
  () => "https://github.com/DaveMBush/eslint-plugin-rxjs/blob/main/packages/eslint-plugin-rxjs/docs/rules/ban-observables.md"
)({
  meta: {
    docs: {
      description: "Forbids the use of banned observables."
    },
    fixable: void 0,
    hasSuggestions: false,
    messages: {
      [messageId]: "RxJS observable is banned: {{name}}{{explanation}}."
    },
    schema: [
      {
        type: "object",
        description: `An object containing keys that are names of observable factory functions and values that are either booleans or strings containing the explanation for the ban.`
      }
    ],
    type: "problem"
  },
  name: "ban-observables",
  defaultOptions,
  create: (context) => {
    const bans = [];
    const [config] = context.options;
    if (!config) {
      return {};
    }
    Object.entries(config).forEach(([key, value]) => {
      if (value !== false) {
        bans.push({
          explanation: typeof value === "string" ? value : "",
          regExp: new RegExp(`^${key}$`)
        });
      }
    });
    function getFailure(name2) {
      for (let b = 0, length = bans.length; b < length; ++b) {
        const ban = bans[b];
        if (ban.regExp.test(name2)) {
          const explanation = ban.explanation ? `: ${ban.explanation}` : "";
          return {
            messageId: "forbidden",
            data: { name: name2, explanation }
          };
        }
      }
      return void 0;
    }
    return {
      "ImportDeclaration[source.value='rxjs'] > ImportSpecifier": (node) => {
        const identifier = node.imported;
        if (identifier.type === import_utils.AST_NODE_TYPES.Identifier) {
          const failure = getFailure(identifier.name);
          if (failure) {
            context.report({
              ...failure,
              node: identifier
            });
          }
        }
      }
    };
  }
});

// packages/eslint-plugin-rxjs/src/lib/rules/ban-operators.ts
var import_utils3 = require("@typescript-eslint/utils");
var import_utils4 = require("@typescript-eslint/utils");
var defaultOptions2 = [];
var messageId2 = "forbidden";
var ban_operators_default = import_utils4.ESLintUtils.RuleCreator(
  () => "https://github.com/DaveMBush/eslint-plugin-rxjs/blob/main/packages/eslint-plugin-rxjs/docs/rules/ban-operators.md"
)({
  meta: {
    docs: {
      description: "Forbids the use of banned operators."
    },
    fixable: void 0,
    hasSuggestions: false,
    messages: {
      [messageId2]: "RxJS operator is banned: {{name}}{{explanation}}."
    },
    schema: [
      {
        type: "object",
        description: `An object containing keys that are names of operators and values that are either booleans or strings containing the explanation for the ban.`
      }
    ],
    type: "problem"
  },
  name: "ban-operators",
  defaultOptions: defaultOptions2,
  create: (context) => {
    const bans = [];
    const [config] = context.options;
    if (!config) {
      return {};
    }
    Object.entries(config).forEach(([key, value]) => {
      if (value !== false) {
        bans.push({
          explanation: typeof value === "string" ? value : "",
          regExp: new RegExp(`^${key}$`)
        });
      }
    });
    function getFailure(name2) {
      for (let b = 0, length = bans.length; b < length; ++b) {
        const ban = bans[b];
        if (ban.regExp.test(name2)) {
          const explanation = ban.explanation ? `: ${ban.explanation}` : "";
          return {
            messageId: "forbidden",
            data: { name: name2, explanation }
          };
        }
      }
      return void 0;
    }
    return {
      [String.raw`ImportDeclaration[source.value=/^rxjs\u002foperators$/] > ImportSpecifier`]: (node) => {
        const identifier = node.imported;
        if (identifier.type === import_utils3.AST_NODE_TYPES.Identifier) {
          const failure = getFailure(identifier.name);
          if (failure) {
            context.report({
              ...failure,
              node: identifier
            });
          }
        }
      }
    };
  }
});

// packages/eslint-plugin-rxjs/src/lib/eslint-etc/get-parent.ts
function getParent(node) {
  return node.parent;
}

// packages/eslint-plugin-rxjs/src/lib/eslint-etc/find-parent.ts
function findParent(node, ...args) {
  const [arg] = args;
  const predicate = typeof arg === "function" ? arg : (type) => args.indexOf(type) === -1 ? "continue" : "return";
  let parent = getParent(node);
  while (parent) {
    switch (predicate(parent.type)) {
      case "break":
        return void 0;
      case "return":
        return parent;
      default:
        break;
    }
    parent = getParent(parent);
  }
  return void 0;
}

// packages/eslint-plugin-rxjs/src/lib/eslint-etc/get-loc.ts
var ts = __toESM(require("typescript"));
function getLoc(node) {
  const sourceFile = node.getSourceFile();
  const start = ts.getLineAndCharacterOfPosition(sourceFile, node.getStart());
  const end = ts.getLineAndCharacterOfPosition(sourceFile, node.getEnd());
  return {
    start: {
      line: start.line + 1,
      column: start.character
    },
    end: {
      line: end.line + 1,
      column: end.character
    }
  };
}

// packages/eslint-plugin-rxjs/src/lib/eslint-etc/get-parser-services.ts
var import_utils5 = require("@typescript-eslint/utils");
var { getParserServices } = import_utils5.ESLintUtils;

// packages/eslint-plugin-rxjs/src/lib/eslint-etc/get-type-services.ts
var import_utils6 = require("@typescript-eslint/utils");

// packages/eslint-plugin-rxjs/src/lib/tsutils-etc/could-implement.function.ts
var ts2 = __toESM(require("typescript"));
function couldImplement(type, name2, qualified) {
  const { symbol } = type;
  if (symbol) {
    const { valueDeclaration } = symbol;
    if (valueDeclaration && ts2.isClassDeclaration(valueDeclaration)) {
      const { heritageClauses } = valueDeclaration;
      if (heritageClauses) {
        const implemented = heritageClauses.some(
          ({ token, types }) => token === ts2.SyntaxKind.ImplementsKeyword && types.some((node) => isMatchingNode(node, name2, qualified))
        );
        if (implemented) {
          return true;
        }
      }
    }
  }
  return false;
}
function isMatchingNode(node, name2, qualified) {
  const { expression } = node;
  if (qualified) {
    const type = qualified.typeChecker.getTypeAtLocation(expression);
    if (type) {
      const qualifiedName = qualified.typeChecker.getFullyQualifiedName(
        type.symbol
      );
      if (!qualified.name.test(qualifiedName)) {
        return false;
      }
    }
  }
  const text = expression.getText();
  return typeof name2 === "string" ? text === name2 : Boolean(text.match(name2));
}

// packages/eslint-plugin-rxjs/src/lib/tsutils-etc/is-intersection-type.function.ts
var tsutils = __toESM(require("ts-api-utils"));
var ts3 = __toESM(require("typescript"));
function isIntersectionType(type) {
  return tsutils.isTypeFlagSet(type, ts3.TypeFlags.Intersection);
}

// packages/eslint-plugin-rxjs/src/lib/tsutils-etc/is-reference-type.function.ts
var tsutils2 = __toESM(require("ts-api-utils"));
var ts4 = __toESM(require("typescript"));
function isReferenceType(type) {
  return tsutils2.isTypeFlagSet(type, ts4.TypeFlags.Object) && tsutils2.isObjectFlagSet(type, ts4.ObjectFlags.Reference);
}

// packages/eslint-plugin-rxjs/src/lib/tsutils-etc/is-type.function.ts
function isType(type, name2, qualified) {
  if (!type.symbol) {
    return false;
  }
  if (qualified && !qualified.name.test(
    qualified.typeChecker.getFullyQualifiedName(type.symbol)
  )) {
    return false;
  }
  return typeof name2 === "string" ? type.symbol.name === name2 : Boolean(type.symbol.name.match(name2));
}

// packages/eslint-plugin-rxjs/src/lib/tsutils-etc/is-union-type.function.ts
var tsutils3 = __toESM(require("ts-api-utils"));
var ts5 = __toESM(require("typescript"));
function isUnionType(type) {
  return tsutils3.isTypeFlagSet(type, ts5.TypeFlags.Union);
}

// packages/eslint-plugin-rxjs/src/lib/tsutils-etc/could-be-type.function.ts
function couldBeType(type, name2, qualified) {
  if (isReferenceType(type)) {
    type = type.target;
  }
  if (isType(type, name2, qualified)) {
    return true;
  }
  if (isIntersectionType(type) || isUnionType(type)) {
    return type.types.some((t) => couldBeType(t, name2, qualified));
  }
  const baseTypes = type.getBaseTypes();
  if (baseTypes && baseTypes.some((t) => couldBeType(t, name2, qualified))) {
    return true;
  }
  if (couldImplement(type, name2, qualified)) {
    return true;
  }
  return false;
}

// packages/eslint-plugin-rxjs/src/lib/tsutils-etc/could-be-function.function.ts
var ts6 = __toESM(require("typescript"));
function couldBeFunction(type) {
  return type.getCallSignatures().length > 0 || couldBeType(type, "Function") || couldBeType(type, "ArrowFunction") || couldBeType(type, ts6.InternalSymbolName.Function);
}

// packages/eslint-plugin-rxjs/src/lib/tsutils-etc/is-any.function.ts
var tsutils4 = __toESM(require("ts-api-utils"));
var ts7 = __toESM(require("typescript"));
function isAny(type) {
  return tsutils4.isTypeFlagSet(type, ts7.TypeFlags.Any);
}

// packages/eslint-plugin-rxjs/src/lib/tsutils-etc/is-unknown.function.ts
var tsutils5 = __toESM(require("ts-api-utils"));
var ts8 = __toESM(require("typescript"));
function isUnknown(type) {
  return tsutils5.isTypeFlagSet(type, ts8.TypeFlags.Unknown);
}

// packages/eslint-plugin-rxjs/src/lib/eslint-etc/get-type-services.ts
var import_typescript = __toESM(require("typescript"));

// packages/eslint-plugin-rxjs/src/lib/eslint-etc/is.ts
function hasTypeAnnotation(node) {
  return "typeAnnotation" in node && !!node.typeAnnotation;
}
function isArrayPattern(node) {
  return node.type === "ArrayPattern";
}
function isArrowFunctionExpression(node) {
  return node.type === "ArrowFunctionExpression";
}
function isBlockStatement(node) {
  return node.type === "BlockStatement";
}
function isCallExpression(node) {
  return node.type === "CallExpression";
}
function isFunctionDeclaration(node) {
  return node.type === "FunctionDeclaration";
}
function isFunctionExpression(node) {
  return node.type === "FunctionExpression";
}
function isIdentifier(node) {
  return node.type === "Identifier";
}
function isLiteral(node) {
  return node.type === "Literal";
}
function isMemberExpression(node) {
  return node.type === "MemberExpression";
}
function isObjectExpression(node) {
  return node.type === "ObjectExpression";
}
function isObjectPattern(node) {
  return node.type === "ObjectPattern";
}
function isProgram(node) {
  return node.type === "Program";
}
function isProperty(node) {
  return node.type === "Property";
}

// packages/eslint-plugin-rxjs/src/lib/eslint-etc/get-type-services.ts
function getTypeServices(context) {
  const services = import_utils6.ESLintUtils.getParserServices(context);
  const { esTreeNodeToTSNodeMap, program } = services;
  const typeChecker = program.getTypeChecker();
  const getType = (node) => {
    const tsNode = esTreeNodeToTSNodeMap.get(node);
    if (!tsNode) {
      return void 0;
    }
    const type = typeChecker.getTypeAtLocation(tsNode);
    if (!type) {
      return void 0;
    }
    return type;
  };
  const couldBeType2 = (node, name2, qualified) => {
    const type = getType(node);
    if (!type) {
      return false;
    }
    const result = couldBeType(
      type,
      name2,
      qualified ? { ...qualified, typeChecker } : void 0
    );
    return result;
  };
  const couldReturnType = (node, name2, qualified) => {
    let tsTypeNode;
    const tsNode = esTreeNodeToTSNodeMap.get(node);
    if (import_typescript.default.isArrowFunction(tsNode) || import_typescript.default.isFunctionDeclaration(tsNode) || import_typescript.default.isMethodDeclaration(tsNode) || import_typescript.default.isFunctionExpression(tsNode)) {
      tsTypeNode = tsNode.type ?? tsNode.body;
    } else if (import_typescript.default.isCallSignatureDeclaration(tsNode) || import_typescript.default.isMethodSignature(tsNode)) {
      tsTypeNode = tsNode.type;
    }
    const result = Boolean(
      tsTypeNode && couldBeType(
        typeChecker.getTypeAtLocation(tsTypeNode),
        name2,
        qualified ? { ...qualified, typeChecker } : void 0
      )
    );
    return result;
  };
  return {
    couldBeBehaviorSubject: (node) => couldBeType2(node, "BehaviorSubject"),
    couldBeError: (node) => couldBeType2(node, "Error"),
    couldBeFunction: (node) => {
      if (isArrowFunctionExpression(node) || isFunctionDeclaration(node)) {
        return true;
      }
      const type = getType(node);
      if (!type) {
        return false;
      }
      return couldBeFunction(type);
    },
    couldBeMonoTypeOperatorFunction: (node) => couldBeType2(node, "MonoTypeOperatorFunction"),
    couldBeObservable: (node) => couldBeType2(node, "Observable"),
    couldBeSubject: (node) => couldBeType2(node, "Subject"),
    couldBeSubscription: (node) => couldBeType2(node, "Subscription"),
    couldBeType: couldBeType2,
    couldReturnObservable: (node) => couldReturnType(node, "Observable"),
    couldReturnType,
    getType,
    isAny: (node) => {
      const type = getType(node);
      if (!type) {
        return false;
      }
      return isAny(type);
    },
    isReferenceType: (node) => {
      const type = getType(node);
      if (!type) {
        return false;
      }
      return isReferenceType(type);
    },
    isUnknown: (node) => {
      const type = getType(node);
      if (!type) {
        return false;
      }
      return isUnknown(type);
    },
    typeChecker
  };
}

// packages/eslint-plugin-rxjs/src/lib/eslint-etc/is-import.ts
function isImport(scope, name2, source) {
  const variable = scope.variables.find((variable2) => variable2.name === name2);
  if (variable) {
    return variable.defs.some(
      (def) => def.type === "ImportBinding" && def.parent.type === "ImportDeclaration" && (typeof source === "string" ? def.parent.source.value === source : source.test(def.parent.source.value))
    );
  }
  return scope.upper ? isImport(scope.upper, name2, source) : false;
}

// packages/eslint-plugin-rxjs/src/lib/rules/finnish.ts
var import_utils7 = require("@typescript-eslint/utils");
var defaultOptions3 = [];
var shouldBeFinnishMessageId = "shouldBeFinnish";
var shouldNotBeFinnishMessageId = "shouldNotBeFinnish";
var finnish_default = import_utils7.ESLintUtils.RuleCreator(
  () => "https://github.com/DaveMBush/eslint-plugin-rxjs/blob/main/packages/eslint-plugin-rxjs/docs/rules/finnish.md"
)({
  meta: {
    docs: {
      description: "Enforces the use of Finnish notation."
    },
    fixable: void 0,
    hasSuggestions: false,
    messages: {
      [shouldBeFinnishMessageId]: "Finnish notation should be used here.",
      [shouldNotBeFinnishMessageId]: "Finnish notation should not be used here."
    },
    schema: [
      {
        properties: {
          functions: { type: "boolean" },
          methods: { type: "boolean" },
          names: { type: "object" },
          parameters: { type: "boolean" },
          properties: { type: "boolean" },
          strict: { type: "boolean" },
          types: { type: "object" },
          variables: { type: "boolean" }
        },
        type: "object"
      }
    ],
    type: "problem"
  },
  name: "finnish",
  defaultOptions: defaultOptions3,
  create: (context) => {
    const { esTreeNodeToTSNodeMap } = getParserServices(context);
    const {
      couldBeObservable,
      couldBeType: couldBeType2,
      couldReturnObservable,
      couldReturnType
    } = getTypeServices(context);
    const [config = {}] = context.options;
    const { strict = false } = config;
    const validate = {
      functions: true,
      methods: true,
      parameters: true,
      properties: true,
      variables: true,
      ...config
    };
    const names = [];
    if (config.names) {
      Object.entries(config.names).forEach(
        ([key, validate2]) => {
          names.push({ regExp: new RegExp(key), validate: validate2 });
        }
      );
    } else {
      names.push({
        regExp: /^(canActivate|canActivateChild|canDeactivate|canLoad|intercept|resolve|validate)$/,
        validate: false
      });
    }
    const types = [];
    if (config.types) {
      Object.entries(config.types).forEach(
        ([key, validate2]) => {
          types.push({ regExp: new RegExp(key), validate: validate2 });
        }
      );
    } else {
      types.push({
        regExp: /^EventEmitter$/,
        validate: false
      });
    }
    function checkNode(nameNode, typeNode) {
      const tsNode = esTreeNodeToTSNodeMap.get(nameNode);
      const text = tsNode.getText();
      const hasFinnish = /\$$/.test(text);
      if (hasFinnish && !strict) {
        return;
      }
      const shouldBeFinnish = hasFinnish ? () => {
      } : () => {
        context.report({
          loc: getLoc(tsNode),
          messageId: "shouldBeFinnish"
        });
      };
      const shouldNotBeFinnish = hasFinnish ? () => {
        context.report({
          loc: getLoc(tsNode),
          messageId: "shouldNotBeFinnish"
        });
      } : () => {
      };
      if (couldBeObservable(typeNode || nameNode) || couldReturnObservable(typeNode || nameNode)) {
        for (const name2 of names) {
          const { regExp, validate: validate2 } = name2;
          if (regExp.test(text) && !validate2) {
            shouldNotBeFinnish();
            return;
          }
        }
        for (const type of types) {
          const { regExp, validate: validate2 } = type;
          if ((couldBeType2(typeNode || nameNode, regExp) || couldReturnType(typeNode || nameNode, regExp)) && !validate2) {
            shouldNotBeFinnish();
            return;
          }
        }
        shouldBeFinnish();
      } else {
        shouldNotBeFinnish();
      }
    }
    return {
      "ArrayPattern > Identifier": (node) => {
        const found = findParent(
          node,
          "ArrowFunctionExpression",
          "FunctionDeclaration",
          "FunctionExpression",
          "VariableDeclarator"
        );
        if (!found) {
          return;
        }
        if (!validate.variables && found.type === "VariableDeclarator") {
          return;
        }
        if (!validate.parameters) {
          return;
        }
        checkNode(node);
      },
      "ArrowFunctionExpression > Identifier": (node) => {
        if (validate.parameters) {
          const parent = getParent(node);
          if (node !== parent.body) {
            checkNode(node);
          }
        }
      },
      "PropertyDefinition[computed=false]": (node) => {
        if (validate.properties) {
          checkNode(node.key);
        }
      },
      "FunctionDeclaration > Identifier": (node) => {
        const parent = getParent(node);
        if (node === parent.id) {
          if (validate.functions) {
            checkNode(node, parent);
          }
        } else {
          if (validate.parameters) {
            checkNode(node);
          }
        }
      },
      "FunctionExpression > Identifier": (node) => {
        const parent = getParent(node);
        if (node === parent.id) {
          if (validate.functions) {
            checkNode(node, parent);
          }
        } else {
          if (validate.parameters) {
            checkNode(node);
          }
        }
      },
      "MethodDefinition[kind='get'][computed=false]": (node) => {
        if (validate.properties) {
          checkNode(node.key, node);
        }
      },
      "MethodDefinition[kind='method'][computed=false]": (node) => {
        if (validate.methods) {
          checkNode(node.key, node);
        }
      },
      "MethodDefinition[kind='set'][computed=false]": (node) => {
        if (validate.properties) {
          checkNode(node.key, node);
        }
      },
      "ObjectExpression > Property[computed=false] > Identifier": (node) => {
        if (validate.properties) {
          const parent = getParent(node);
          if (node === parent.key) {
            checkNode(node);
          }
        }
      },
      "ObjectPattern > Property > Identifier": (node) => {
        const found = findParent(
          node,
          "ArrowFunctionExpression",
          "FunctionDeclaration",
          "FunctionExpression",
          "VariableDeclarator"
        );
        if (!found) {
          return;
        }
        if (!validate.variables && found.type === "VariableDeclarator") {
          return;
        }
        if (!validate.parameters) {
          return;
        }
        const parent = getParent(node);
        if (node === parent.value) {
          checkNode(node);
        }
      },
      "TSCallSignatureDeclaration > Identifier": (node) => {
        if (validate.parameters) {
          checkNode(node);
        }
      },
      "TSConstructSignatureDeclaration > Identifier": (node) => {
        if (validate.parameters) {
          checkNode(node);
        }
      },
      "TSMethodSignature[computed=false]": (node) => {
        if (validate.methods) {
          checkNode(node.key, node);
        }
        if (validate.parameters) {
          node.params.forEach((param) => checkNode(param));
        }
      },
      "TSParameterProperty > Identifier": (node) => {
        if (validate.parameters || validate.properties) {
          checkNode(node);
        }
      },
      "TSPropertySignature[computed=false]": (node) => {
        if (validate.properties) {
          checkNode(node.key);
        }
      },
      "VariableDeclarator > Identifier": (node) => {
        const parent = getParent(node);
        if (validate.variables && node === parent.id) {
          checkNode(node);
        }
      }
    };
  }
});

// packages/eslint-plugin-rxjs/src/lib/rules/just.ts
var import_utils8 = require("@typescript-eslint/utils");
var messageId3 = "forbidden";
var just_default = import_utils8.ESLintUtils.RuleCreator(
  () => "https://github.com/DaveMBush/eslint-plugin-rxjs/blob/main/packages/eslint-plugin-rxjs/docs/rules/just.md"
)({
  meta: {
    docs: {
      description: "Enforces the use of a `just` alias for `of`."
    },
    fixable: "code",
    hasSuggestions: false,
    messages: {
      [messageId3]: "Use just alias."
    },
    schema: [],
    type: "problem"
  },
  name: "just",
  defaultOptions: [],
  create: (context) => {
    return {
      "ImportDeclaration[source.value='rxjs'] > ImportSpecifier[imported.name='of']": (node) => {
        if (node.local.range[0] !== node.imported.range[0] && node.local.range[1] !== node.imported.range[1]) {
          return;
        }
        context.report({
          messageId: messageId3,
          node,
          fix: (fixer) => fixer.replaceTextRange(node.range, "of as just")
        });
        const [ofImport] = context.sourceCode.getDeclaredVariables(node);
        ofImport.references.forEach((ref) => {
          context.report({
            messageId: messageId3,
            node: ref.identifier,
            fix: (fixer) => fixer.replaceTextRange(ref.identifier.range, "just")
          });
        });
      }
    };
  }
});

// packages/eslint-plugin-rxjs/src/lib/rules/macro.ts
var import_utils9 = require("@typescript-eslint/utils");
var messageId4 = "macro";
var macro_default = import_utils9.ESLintUtils.RuleCreator(
  () => "https://github.com/DaveMBush/eslint-plugin-rxjs/blob/main/packages/eslint-plugin-rxjs/docs/rules/macro.md"
)({
  meta: {
    docs: {
      description: "Enforces the use of the RxJS Tools Babel macro."
    },
    fixable: "code",
    hasSuggestions: false,
    messages: {
      [messageId4]: "Use the RxJS Tools Babel macro."
    },
    schema: [],
    type: "problem"
  },
  name: "macro",
  defaultOptions: [],
  create: (context) => {
    let hasFailure = false;
    let hasMacroImport = false;
    let program = void 0;
    function fix(fixer) {
      return fixer.insertTextBefore(
        /* eslint-disable-next-line @typescript-eslint/no-non-null-assertion */
        program,
        `import "babel-plugin-rxjs-tools/macro";
`
      );
    }
    return {
      "CallExpression[callee.property.name=/^(pipe|subscribe)$/]": (node) => {
        if (hasFailure || hasMacroImport) {
          return;
        }
        hasFailure = true;
        context.report({
          fix,
          messageId: messageId4,
          node: node.callee
        });
      },
      "ImportDeclaration[source.value='babel-plugin-rxjs-tools/macro']": (node) => {
        hasMacroImport = true;
      },
      [String.raw`ImportDeclaration[source.value=/^rxjs(\u002f|$)/]`]: (node) => {
        if (hasFailure || hasMacroImport) {
          return;
        }
        hasFailure = true;
        context.report({
          fix,
          messageId: "macro",
          node
        });
      },
      Program: (node) => {
        program = node;
      }
    };
  }
});

// packages/eslint-plugin-rxjs/src/lib/rules/no-async-subscribe.ts
var import_utils10 = require("@typescript-eslint/utils");
var messageId5 = "forbidden";
var no_async_subscribe_default = import_utils10.ESLintUtils.RuleCreator(
  () => "https://github.com/DaveMBush/eslint-plugin-rxjs/blob/main/packages/eslint-plugin-rxjs/docs/rules/no-async-subscribe.md"
)({
  meta: {
    docs: {
      description: "Forbids passing `async` functions to `subscribe`."
    },
    fixable: void 0,
    hasSuggestions: false,
    messages: {
      [messageId5]: "Passing async functions to subscribe is forbidden."
    },
    schema: [],
    type: "problem"
  },
  name: "no-async-subscribe",
  defaultOptions: [],
  create: (context) => {
    const { couldBeObservable } = getTypeServices(context);
    function checkNode(node) {
      const parentNode = getParent(node);
      const callee = parentNode.callee;
      if (couldBeObservable(callee.object)) {
        const { loc } = node;
        const asyncLoc = {
          ...loc,
          end: {
            ...loc.start,
            column: loc.start.column + 5
          }
        };
        context.report({
          messageId: messageId5,
          loc: asyncLoc
        });
      }
    }
    return {
      "CallExpression[callee.property.name='subscribe'] > FunctionExpression[async=true]": checkNode,
      "CallExpression[callee.property.name='subscribe'] > ArrowFunctionExpression[async=true]": checkNode
    };
  }
});

// packages/eslint-plugin-rxjs/src/lib/rules/no-compat.ts
var import_utils11 = require("@typescript-eslint/utils");
var messageId6 = "forbidden";
var no_compat_default = import_utils11.ESLintUtils.RuleCreator(
  () => "https://github.com/DaveMBush/eslint-plugin-rxjs/blob/main/packages/eslint-plugin-rxjs/docs/rules/no-compat.md"
)({
  meta: {
    docs: {
      description: "Forbids importation from locations that depend upon `rxjs-compat`."
    },
    fixable: void 0,
    hasSuggestions: false,
    messages: {
      [messageId6]: "'rxjs-compat'-dependent import locations are forbidden."
    },
    schema: [],
    type: "problem"
  },
  name: "no-compat",
  defaultOptions: [],
  create: (context) => {
    return {
      [String.raw`ImportDeclaration Literal[value=/^rxjs\u002f/]:not(Literal[value=/^rxjs\u002f(ajax|fetch|operators|testing|webSocket)/])`]: (node) => {
        context.report({
          messageId: messageId6,
          node
        });
      }
    };
  }
});

// packages/eslint-plugin-rxjs/src/lib/rules/no-connectable.ts
var import_utils12 = require("@typescript-eslint/utils");
var messageId7 = "forbidden";
var no_connectable_default = import_utils12.ESLintUtils.RuleCreator(
  () => "https://github.com/DaveMBush/eslint-plugin-rxjs/blob/main/packages/eslint-plugin-rxjs/docs/rules/no-connectable.md"
)({
  meta: {
    docs: {
      description: "Forbids operators that return connectable observables."
    },
    fixable: void 0,
    hasSuggestions: false,
    messages: {
      [messageId7]: "Connectable observables are forbidden."
    },
    schema: [],
    type: "problem"
  },
  name: "no-connectable",
  defaultOptions: [],
  create: (context) => {
    const { couldBeFunction: couldBeFunction2 } = getTypeServices(context);
    return {
      "CallExpression[callee.name='multicast']": (node) => {
        if (node.arguments.length === 1) {
          context.report({
            messageId: messageId7,
            node: node.callee
          });
        }
      },
      "CallExpression[callee.name=/^(publish|publishBehavior|publishLast|publishReplay)$/]": (node) => {
        if (!node.arguments.some((arg) => couldBeFunction2(arg))) {
          context.report({
            messageId: messageId7,
            node: node.callee
          });
        }
      }
    };
  }
});

// packages/eslint-plugin-rxjs/src/lib/rules/no-create.ts
var import_utils13 = require("@typescript-eslint/utils");
var messageId8 = "forbidden";
var no_create_default = import_utils13.ESLintUtils.RuleCreator(
  () => "https://github.com/DaveMBush/eslint-plugin-rxjs/blob/main/packages/eslint-plugin-rxjs/docs/rules/no-create.md"
)({
  meta: {
    docs: {
      description: "Forbids the calling of `Observable.create`."
    },
    fixable: void 0,
    hasSuggestions: false,
    messages: {
      [messageId8]: "Observable.create is forbidden; use new Observable."
    },
    schema: [],
    type: "problem"
  },
  name: "no-create",
  defaultOptions: [],
  create: (context) => {
    const { couldBeObservable } = getTypeServices(context);
    return {
      "CallExpression > MemberExpression[object.name='Observable'] > Identifier[name='create']": (node) => {
        const memberExpression = getParent(node);
        if (couldBeObservable(memberExpression.object)) {
          context.report({
            messageId: messageId8,
            node
          });
        }
      }
    };
  }
});

// packages/eslint-plugin-rxjs/src/lib/rules/no-cyclic-action.ts
var import_typescript2 = __toESM(require("typescript"));

// packages/eslint-plugin-rxjs/src/lib/constants.ts
var defaultObservable = String.raw`[Aa]ction(s|s\$|\$)$`;

// packages/eslint-plugin-rxjs/src/lib/rules/no-cyclic-action.ts
var import_utils14 = require("@typescript-eslint/utils");
function isTypeReference(type) {
  return Boolean(type.target);
}
var messageId9 = "forbidden";
var defaultOptions4 = [];
var no_cyclic_action_default = import_utils14.ESLintUtils.RuleCreator(
  () => "https://github.com/DaveMBush/eslint-plugin-rxjs/blob/main/packages/eslint-plugin-rxjs/docs/rules/no-cyclic-action.md"
)({
  meta: {
    docs: {
      description: "Forbids effects and epics that re-emit filtered actions."
    },
    fixable: void 0,
    hasSuggestions: false,
    messages: {
      [messageId9]: "Effects and epics that re-emit filtered actions are forbidden."
    },
    schema: [
      {
        properties: {
          observable: { type: "string" }
        },
        type: "object",
        description: `An optional object with an optional \`observable\` property. The property can be specified as a regular expression string and is used to identify the action observables from which effects and epics are composed.`
      }
    ],
    type: "problem"
  },
  name: "no-cyclic-action",
  defaultOptions: defaultOptions4,
  create: (context) => {
    const [config = {}] = context.options;
    const { observable = defaultObservable } = config;
    const observableRegExp = new RegExp(observable);
    const { getType, typeChecker } = getTypeServices(context);
    function checkNode(pipeCallExpression) {
      const operatorCallExpression = pipeCallExpression.arguments.find(
        (arg) => isCallExpression(arg) && isIdentifier(arg.callee) && arg.callee.name === "ofType"
      );
      if (!operatorCallExpression) {
        return;
      }
      const operatorType = getType(operatorCallExpression);
      if (!operatorType) {
        return;
      }
      const [signature] = typeChecker.getSignaturesOfType(
        operatorType,
        import_typescript2.default.SignatureKind.Call
      );
      if (!signature) {
        return;
      }
      const operatorReturnType = typeChecker.getReturnTypeOfSignature(signature);
      if (!isTypeReference(operatorReturnType)) {
        return;
      }
      const [operatorElementType] = typeChecker.getTypeArguments(operatorReturnType);
      if (!operatorElementType) {
        return;
      }
      const pipeType = getType(pipeCallExpression);
      if (!pipeType || !isTypeReference(pipeType)) {
        return;
      }
      const [pipeElementType] = typeChecker.getTypeArguments(pipeType);
      if (!pipeElementType) {
        return;
      }
      const operatorActionTypes = getActionTypes(operatorElementType);
      const pipeActionTypes = getActionTypes(pipeElementType);
      for (const actionType of operatorActionTypes) {
        if (pipeActionTypes.includes(actionType)) {
          context.report({
            messageId: messageId9,
            node: pipeCallExpression.callee
          });
          return;
        }
      }
    }
    function getActionTypes(type) {
      if (type.isUnion()) {
        const memberActionTypes = [];
        for (const memberType of type.types) {
          memberActionTypes.push(...getActionTypes(memberType));
        }
        return memberActionTypes;
      }
      const symbol = typeChecker.getPropertyOfType(type, "type");
      if (!symbol || !symbol.valueDeclaration) {
        return [];
      }
      const actionType = typeChecker.getTypeOfSymbolAtLocation(
        symbol,
        symbol.valueDeclaration
      );
      return [typeChecker.typeToString(actionType)];
    }
    return {
      [`CallExpression[callee.property.name='pipe'][callee.object.name=${observableRegExp}]`]: checkNode,
      [`CallExpression[callee.property.name='pipe'][callee.object.property.name=${observableRegExp}]`]: checkNode
    };
  }
});

// packages/eslint-plugin-rxjs/src/lib/rules/no-exposed-subjects.ts
var import_utils15 = require("@typescript-eslint/utils");
var defaultAllowedTypesRegExp = /^EventEmitter$/;
var defaultOptions5 = [];
var forbiddenId = "forbidden";
var forbiddenAllowProtectedId = "forbiddenAllowProtected";
var no_exposed_subjects_default = import_utils15.ESLintUtils.RuleCreator(
  () => "https://github.com/DaveMBush/eslint-plugin-rxjs/blob/main/packages/eslint-plugin-rxjs/docs/rules/no-exposed-subjects.md"
)({
  meta: {
    docs: {
      description: "Forbids exposed (i.e. non-private) subjects."
    },
    fixable: void 0,
    hasSuggestions: false,
    messages: {
      [forbiddenId]: "Subject '{{subject}}' must be private.",
      [forbiddenAllowProtectedId]: "Subject '{{subject}}' must be private or protected."
    },
    schema: [
      {
        properties: {
          allowProtected: { type: "boolean" }
        },
        type: "object"
      }
    ],
    type: "problem"
  },
  name: "no-exposed-subjects",
  defaultOptions: defaultOptions5,
  create: (context) => {
    const [config = {}] = context.options;
    const { allowProtected = false } = config;
    const { couldBeSubject, couldBeType: couldBeType2 } = getTypeServices(context);
    const messageId33 = allowProtected ? forbiddenAllowProtectedId : forbiddenId;
    const accessibilityRexExp = allowProtected ? /^(private|protected)$/ : /^private$/;
    function isSubject(node) {
      return couldBeSubject(node) && !couldBeType2(node, defaultAllowedTypesRegExp);
    }
    return {
      [`PropertyDefinition[accessibility!=${accessibilityRexExp}]`]: (node) => {
        if (isSubject(node)) {
          const { key } = node;
          if (isIdentifier(key)) {
            context.report({
              messageId: messageId33,
              node: key,
              data: {
                subject: key.name
              }
            });
          }
        }
      },
      [`MethodDefinition[kind='constructor'] > FunctionExpression > TSParameterProperty[accessibility!=${accessibilityRexExp}] > Identifier`]: (node) => {
        if (isSubject(node)) {
          const { loc } = node;
          context.report({
            messageId: messageId33,
            loc: {
              ...loc,
              end: {
                ...loc.start,
                column: loc.start.column + node.name.length
              }
            },
            data: {
              subject: node.name
            }
          });
        }
      },
      [`MethodDefinition[accessibility!=${accessibilityRexExp}][kind=/^(get|set)$/]`]: (node) => {
        if (isSubject(node)) {
          const key = node.key;
          context.report({
            messageId: messageId33,
            node: key,
            data: {
              subject: key.name
            }
          });
        }
      },
      [`MethodDefinition[accessibility!=${accessibilityRexExp}][kind='method']`]: (node) => {
        const functionExpression = node.value;
        const returnType = functionExpression.returnType;
        if (!returnType) {
          return;
        }
        const typeAnnotation = returnType.typeAnnotation;
        if (!typeAnnotation) {
          return;
        }
        if (isSubject(typeAnnotation)) {
          const key = node.key;
          context.report({
            messageId: messageId33,
            node: key,
            data: {
              subject: key.name
            }
          });
        }
      }
    };
  }
});

// packages/eslint-plugin-rxjs/src/lib/rules/no-finnish.ts
var import_utils16 = require("@typescript-eslint/utils");
var messageId10 = "forbidden";
var no_finnish_default = import_utils16.ESLintUtils.RuleCreator(
  () => "https://github.com/DaveMBush/eslint-plugin-rxjs/blob/main/packages/eslint-plugin-rxjs/docs/rules/no-finnish.md"
)({
  meta: {
    docs: {
      description: "Forbids the use of Finnish notation."
    },
    fixable: void 0,
    hasSuggestions: false,
    messages: {
      [messageId10]: "Finnish notation is forbidden."
    },
    schema: [],
    type: "problem"
  },
  name: "no-finnish",
  defaultOptions: [],
  create: (context) => {
    const { esTreeNodeToTSNodeMap } = getParserServices(context);
    const { couldBeObservable, couldReturnObservable } = getTypeServices(context);
    function checkNode(nameNode, typeNode) {
      if (couldBeObservable(typeNode || nameNode) || couldReturnObservable(typeNode || nameNode)) {
        const tsNode = esTreeNodeToTSNodeMap.get(nameNode);
        if (/[$]+$/.test(tsNode.getText())) {
          context.report({
            loc: getLoc(tsNode),
            messageId: messageId10
          });
        }
      }
    }
    return {
      "ArrayPattern > Identifier[name=/[$]+$/]": (node) => checkNode(node),
      "ArrowFunctionExpression > Identifier[name=/[$]+$/]": (node) => {
        const parent = getParent(node);
        if (node !== parent.body) {
          checkNode(node);
        }
      },
      "PropertyDefinition[key.name=/[$]+$/] > Identifier": (node) => checkNode(node, getParent(node)),
      "FunctionDeclaration > Identifier[name=/[$]+$/]": (node) => {
        const parent = getParent(node);
        if (node === parent.id) {
          checkNode(node, parent);
        } else {
          checkNode(node);
        }
      },
      "FunctionExpression > Identifier[name=/[$]+$/]": (node) => {
        const parent = getParent(node);
        if (node === parent.id) {
          checkNode(node, parent);
        } else {
          checkNode(node);
        }
      },
      "MethodDefinition[key.name=/[$]+$/]": (node) => checkNode(node.key, node),
      "ObjectExpression > Property[computed=false][key.name=/[$]+$/]": (node) => checkNode(node.key),
      "ObjectPattern > Property[value.name=/[$]+$/]": (node) => checkNode(node.value),
      "TSCallSignatureDeclaration > Identifier[name=/[$]+$/]": (node) => checkNode(node),
      "TSConstructSignatureDeclaration > Identifier[name=/[$]+$/]": (node) => checkNode(node),
      "TSParameterProperty > Identifier[name=/[$]+$/]": (node) => checkNode(node),
      "TSPropertySignature > Identifier[name=/[$]+$/]": (node) => checkNode(node, getParent(node)),
      "TSMethodSignature > Identifier[name=/[$]+$/]": (node) => {
        const parent = getParent(node);
        if (node === parent.key) {
          checkNode(node, parent);
        } else {
          checkNode(node);
        }
      },
      "VariableDeclarator[id.name=/[$]+$/]": (node) => checkNode(node.id, node.init ?? node)
    };
  }
});

// packages/eslint-plugin-rxjs/src/lib/rules/no-ignored-error.ts
var import_utils17 = require("@typescript-eslint/utils");
var messageId11 = "forbidden";
var no_ignored_error_default = import_utils17.ESLintUtils.RuleCreator(
  () => "https://github.com/DaveMBush/eslint-plugin-rxjs/blob/main/packages/eslint-plugin-rxjs/docs/rules/no-ignored-error.md"
)({
  meta: {
    docs: {
      description: "Forbids the calling of `subscribe` without specifying an error handler."
    },
    fixable: void 0,
    hasSuggestions: false,
    messages: {
      [messageId11]: "Calling subscribe without an error handler is forbidden."
    },
    schema: [],
    type: "problem"
  },
  name: "no-ignored-error",
  defaultOptions: [],
  create: (context) => {
    const { couldBeObservable, couldBeFunction: couldBeFunction2 } = getTypeServices(context);
    function hasErrorHandler(arg) {
      if (arg.type === "ObjectExpression") {
        return arg.properties.some(
          (prop) => prop.type === "Property" && "name" in prop.key && prop.key.name === "error"
        );
      }
      return false;
    }
    return {
      "CallExpression[arguments.length > 0] > MemberExpression > Identifier[name='subscribe']": (node) => {
        const memberExpression = getParent(node);
        const callExpression = getParent(
          memberExpression
        );
        const [firstArg] = callExpression.arguments;
        if (couldBeObservable(memberExpression.object) && (callExpression.arguments.length < 2 && couldBeFunction2(firstArg) || firstArg.type === "ObjectExpression" && !hasErrorHandler(firstArg))) {
          context.report({
            messageId: messageId11,
            node
          });
        }
      }
    };
  }
});

// packages/eslint-plugin-rxjs/src/lib/rules/no-ignored-notifier.ts
var import_utils18 = require("@typescript-eslint/utils");
var messageId12 = "forbidden";
var no_ignored_notifier_default = import_utils18.ESLintUtils.RuleCreator(
  () => "https://github.com/DaveMBush/eslint-plugin-rxjs/blob/main/packages/eslint-plugin-rxjs/docs/rules/no-ignored-notifier.md"
)({
  meta: {
    docs: {
      description: "Forbids observables not composed from the `repeatWhen` or `retryWhen` notifier."
    },
    fixable: void 0,
    hasSuggestions: false,
    messages: {
      [messageId12]: "Ignoring the notifier is forbidden."
    },
    schema: [],
    type: "problem"
  },
  name: "no-ignored-notifier",
  defaultOptions: [],
  create: (context) => {
    const { couldBeMonoTypeOperatorFunction } = getTypeServices(context);
    const entries = [];
    function getEntry() {
      const { length, [length - 1]: entry } = entries;
      return entry;
    }
    return {
      "CallExpression[callee.name=/^(repeatWhen|retryWhen)$/]": (node) => {
        if (couldBeMonoTypeOperatorFunction(node)) {
          const [arg] = node.arguments;
          if (isArrowFunctionExpression(arg) || isFunctionExpression(arg)) {
            const [param] = arg.params;
            if (param) {
              entries.push({
                node,
                param,
                sightings: 0
              });
            } else {
              context.report({
                messageId: messageId12,
                node: node.callee
              });
            }
          }
        }
      },
      "CallExpression[callee.name=/^(repeatWhen|retryWhen)$/]:exit": (node) => {
        const entry = getEntry();
        if (!entry) {
          return;
        }
        if (entry.node === node) {
          if (entry.sightings < 2) {
            context.report({
              messageId: messageId12,
              node: node.callee
            });
          }
          entries.pop();
        }
      },
      Identifier: (node) => {
        const entry = getEntry();
        if (!entry) {
          return;
        }
        if (node.name === entry.param.name) {
          ++entry.sightings;
        }
      }
    };
  }
});

// packages/eslint-plugin-rxjs/src/lib/rules/no-ignored-observable.ts
var import_utils19 = require("@typescript-eslint/utils");
var messageId13 = "forbidden";
var no_ignored_observable_default = import_utils19.ESLintUtils.RuleCreator(
  () => "https://github.com/DaveMBush/eslint-plugin-rxjs/blob/main/packages/eslint-plugin-rxjs/docs/rules/no-ignored-observable.md"
)({
  meta: {
    docs: {
      description: "Forbids the ignoring of observables returned by functions."
    },
    fixable: void 0,
    hasSuggestions: false,
    messages: {
      [messageId13]: "Ignoring a returned Observable is forbidden."
    },
    schema: [],
    type: "problem"
  },
  name: "no-ignored-observable",
  defaultOptions: [],
  create: (context) => {
    const { couldBeObservable } = getTypeServices(context);
    return {
      "ExpressionStatement > CallExpression": (node) => {
        if (couldBeObservable(node)) {
          context.report({
            messageId: messageId13,
            node
          });
        }
      }
    };
  }
});

// packages/eslint-plugin-rxjs/src/lib/rules/no-ignored-replay-buffer.ts
var import_utils20 = require("@typescript-eslint/utils");
var import_utils21 = require("@typescript-eslint/utils");
var messageId14 = "forbidden";
var no_ignored_replay_buffer_default = import_utils21.ESLintUtils.RuleCreator(
  () => "https://github.com/DaveMBush/eslint-plugin-rxjs/blob/main/packages/eslint-plugin-rxjs/docs/rules/no-ignored-replay-buffer.md"
)({
  meta: {
    docs: {
      description: "Forbids using `ReplaySubject`, `publishReplay` or `shareReplay` without specifying the buffer size."
    },
    fixable: void 0,
    hasSuggestions: false,
    messages: {
      [messageId14]: "Ignoring the buffer size is forbidden."
    },
    schema: [],
    type: "problem"
  },
  name: "no-ignored-replay-buffer",
  defaultOptions: [],
  create: (context) => {
    function checkShareReplayConfig(node, shareReplayConfigArg) {
      if (!shareReplayConfigArg.properties.some(
        (p) => p.type === import_utils20.AST_NODE_TYPES.Property && p.key.type === import_utils20.AST_NODE_TYPES.Identifier && p.key.name === "bufferSize"
      )) {
        context.report({
          messageId: "forbidden",
          node
        });
      }
    }
    function checkNode(node, { arguments: args }) {
      if (!args || args.length === 0) {
        context.report({
          messageId: "forbidden",
          node
        });
      }
      if (node.name === "shareReplay" && args?.length === 1) {
        const arg = args[0];
        if (arg.type === import_utils20.AST_NODE_TYPES.ObjectExpression) {
          checkShareReplayConfig(node, arg);
        }
      }
    }
    return {
      "NewExpression > Identifier[name='ReplaySubject']": (node) => {
        const newExpression = node.parent;
        checkNode(node, newExpression);
      },
      "NewExpression > MemberExpression > Identifier[name='ReplaySubject']": (node) => {
        const memberExpression = node.parent;
        const newExpression = memberExpression.parent;
        checkNode(node, newExpression);
      },
      "CallExpression > Identifier[name=/^(publishReplay|shareReplay)$/]": (node) => {
        const callExpression = node.parent;
        checkNode(node, callExpression);
      },
      "CallExpression > MemberExpression > Identifier[name=/^(publishReplay|shareReplay)$/]": (node) => {
        const memberExpression = node.parent;
        const callExpression = memberExpression.parent;
        checkNode(node, callExpression);
      }
    };
  }
});

// packages/eslint-plugin-rxjs/src/lib/rules/no-ignored-subscribe.ts
var import_utils22 = require("@typescript-eslint/utils");
var messageId15 = "forbidden";
var no_ignored_subscribe_default = import_utils22.ESLintUtils.RuleCreator(
  () => "https://github.com/DaveMBush/eslint-plugin-rxjs/blob/main/packages/eslint-plugin-rxjs/docs/rules/no-ignored-subscribe.md"
)({
  meta: {
    docs: {
      description: "Forbids the calling of `subscribe` without specifying arguments."
    },
    fixable: void 0,
    hasSuggestions: false,
    messages: {
      [messageId15]: "Calling subscribe without arguments is forbidden."
    },
    schema: [],
    type: "problem"
  },
  name: "no-ignored-subscribe",
  defaultOptions: [],
  create: (context) => {
    const { couldBeObservable, couldBeType: couldBeType2 } = getTypeServices(context);
    return {
      "CallExpression[arguments.length = 0][callee.property.name='subscribe']": (node) => {
        const callee = node.callee;
        if (couldBeObservable(callee.object) || couldBeType2(callee.object, "Subscribable")) {
          context.report({
            messageId: messageId15,
            node: callee.property
          });
        }
      }
    };
  }
});

// packages/eslint-plugin-rxjs/src/lib/rules/no-ignored-subscription.ts
var import_utils23 = require("@typescript-eslint/utils");
var messageId16 = "forbidden";
var no_ignored_subscription_default = import_utils23.ESLintUtils.RuleCreator(
  () => "https://github.com/DaveMBush/eslint-plugin-rxjs/blob/main/packages/eslint-plugin-rxjs/docs/rules/no-ignored-subscription.md"
)({
  meta: {
    docs: {
      description: "Forbids ignoring the subscription returned by `subscribe`."
    },
    fixable: void 0,
    hasSuggestions: false,
    messages: {
      [messageId16]: "Ignoring returned subscriptions is forbidden."
    },
    schema: [],
    type: "problem"
  },
  name: "no-ignored-subscription",
  defaultOptions: [],
  create: (context) => {
    const { couldBeObservable, couldBeType: couldBeType2 } = getTypeServices(context);
    return {
      "ExpressionStatement > CallExpression > MemberExpression[property.name='subscribe']": (node) => {
        if (couldBeObservable(node.object)) {
          const callExpression = getParent(node);
          if (callExpression.arguments.length === 1 && couldBeType2(callExpression.arguments[0], "Subscriber")) {
            return;
          }
          context.report({
            messageId: messageId16,
            node: node.property
          });
        }
      }
    };
  }
});

// packages/eslint-plugin-rxjs/src/lib/rules/no-ignored-takewhile-value.ts
var import_utils24 = require("@typescript-eslint/utils");
var messageId17 = "forbidden";
var no_ignored_takewhile_value_default = import_utils24.ESLintUtils.RuleCreator(
  () => "https://github.com/DaveMBush/eslint-plugin-rxjs/blob/main/packages/eslint-plugin-rxjs/docs/rules/no-ignored-takewhile-value.md"
)({
  meta: {
    docs: {
      description: "Forbids ignoring the value within `takeWhile`."
    },
    fixable: void 0,
    hasSuggestions: false,
    messages: {
      [messageId17]: "Ignoring the value within takeWhile is forbidden."
    },
    schema: [],
    type: "problem"
  },
  name: "no-ignored-takewhile-value",
  defaultOptions: [],
  create: (context) => {
    function checkNode(expression) {
      const scope = context.sourceCode.getScope(expression);
      if (!isImport(scope, "takeWhile", /^rxjs\/?/)) {
        return;
      }
      let ignored = true;
      const [param] = expression.params;
      if (param) {
        if (isIdentifier(param)) {
          const variable = scope.variables.find(
            ({ name: name2 }) => name2 === param.name
          );
          if (variable && variable.references.length > 0) {
            ignored = false;
          }
        } else if (isArrayPattern(param)) {
          ignored = false;
        } else if (isObjectPattern(param)) {
          ignored = false;
        }
      }
      if (ignored) {
        context.report({
          messageId: messageId17,
          node: expression
        });
      }
    }
    return {
      "CallExpression[callee.name='takeWhile'] > ArrowFunctionExpression": (node) => checkNode(node),
      "CallExpression[callee.name='takeWhile'] > FunctionExpression": (node) => checkNode(node)
    };
  }
});

// packages/eslint-plugin-rxjs/src/lib/rules/no-implicit-any-catch.ts
var import_utils25 = require("@typescript-eslint/utils");
var import_utils26 = require("@typescript-eslint/utils");
function isParenthesised(sourceCode, node) {
  const before = sourceCode.getTokenBefore(node);
  const after = sourceCode.getTokenAfter(node);
  return before && after && before.value === "(" && before.range[1] <= node.range[0] && after.value === ")" && after.range[0] >= node.range[1];
}
var defaultOptions6 = [];
var explicitAnyId = "explicitAny";
var implicitAnyId = "implicitAny";
var narrowedId = "narrowed";
var suggestExplicitUnknownId = "suggestExplicitUnknown";
var no_implicit_any_catch_default = import_utils26.ESLintUtils.RuleCreator(
  () => "https://github.com/DaveMBush/eslint-plugin-rxjs/blob/main/packages/eslint-plugin-rxjs/docs/rules/no-implicit-any-catch.md"
)({
  meta: {
    docs: {
      description: "Forbids implicit `any` error parameters in `catchError` operators."
    },
    fixable: "code",
    hasSuggestions: true,
    messages: {
      [explicitAnyId]: "Explicit `any` in `catchError`.",
      [implicitAnyId]: "Implicit `any` in `catchError`.",
      [narrowedId]: "Error type must be `unknown` or `any`.",
      [suggestExplicitUnknownId]: "Use `unknown` instead, this will force you to explicitly and safely assert the type is correct."
    },
    schema: [
      {
        additionalProperties: false,
        properties: {
          allowExplicitAny: {
            type: "boolean"
          }
        },
        type: "object"
      }
    ],
    type: "suggestion"
  },
  name: "no-implicit-any-catch",
  defaultOptions: defaultOptions6,
  create: (context) => {
    const [config = {}] = context.options;
    const { allowExplicitAny = false } = config;
    const { couldBeObservable } = getTypeServices(context);
    const sourceCode = context.sourceCode;
    function checkCallback(callback) {
      if (isArrowFunctionExpression(callback) || isFunctionExpression(callback)) {
        const [param, secondParam] = callback.params;
        if (!param) {
          return;
        }
        if (hasTypeAnnotation(param)) {
          const { typeAnnotation } = param;
          const {
            typeAnnotation: { type }
          } = typeAnnotation;
          if (type === import_utils25.AST_NODE_TYPES.TSAnyKeyword) {
            let fix2 = function(fixer) {
              return fixer.replaceText(typeAnnotation, ": unknown");
            };
            var fix = fix2;
            if (allowExplicitAny) {
              return;
            }
            context.report({
              fix: fix2,
              messageId: explicitAnyId,
              node: param,
              suggest: [
                {
                  messageId: suggestExplicitUnknownId,
                  fix: fix2
                }
              ]
            });
          } else if (type !== import_utils25.AST_NODE_TYPES.TSUnknownKeyword) {
            let fix2 = function(fixer) {
              return fixer.replaceText(typeAnnotation, ": unknown");
            };
            var fix = fix2;
            context.report({
              messageId: narrowedId,
              node: param,
              suggest: [
                {
                  messageId: suggestExplicitUnknownId,
                  fix: fix2
                }
              ]
            });
          }
        } else {
          let fix2 = function(fixer) {
            if (secondParam) {
              if (isParenthesised(sourceCode, param)) {
                return fixer.insertTextAfter(param, ": unknown");
              }
              const tokenBefore = sourceCode.getTokenBefore(param);
              const tokenAfter = sourceCode.getTokenAfter(secondParam);
              if (tokenBefore && tokenBefore.value === "(" && tokenAfter && tokenAfter.value === ")") {
                const paramsText = `${sourceCode.getText(param)}: unknown, ${sourceCode.getText(secondParam)}`;
                return fixer.replaceTextRange(
                  [tokenBefore.range[0], tokenAfter.range[1]],
                  `(${paramsText})`
                );
              } else {
                const paramsText = `${sourceCode.getText(param)}: unknown, ${sourceCode.getText(secondParam)}`;
                return fixer.replaceTextRange(
                  [param.range[0], secondParam.range[1]],
                  `(${paramsText})`
                );
              }
            } else {
              if (isParenthesised(sourceCode, param)) {
                return fixer.insertTextAfter(param, ": unknown");
              }
              return [
                fixer.insertTextBefore(param, "("),
                fixer.insertTextAfter(param, ": unknown)")
              ];
            }
          };
          var fix = fix2;
          context.report({
            fix: fix2,
            messageId: implicitAnyId,
            node: param,
            ...secondParam && callback.params.length === 2 ? {} : {
              suggest: [
                {
                  messageId: suggestExplicitUnknownId,
                  fix: fix2
                }
              ]
            }
          });
        }
      }
    }
    return {
      "CallExpression[callee.name='catchError']": (node) => {
        const [callback] = node.arguments;
        if (!callback) {
          return;
        }
        checkCallback(callback);
      },
      "CallExpression[callee.property.name='subscribe'],CallExpression[callee.name='tap']": (node) => {
        const { callee } = node;
        if (isMemberExpression(callee) && !couldBeObservable(callee.object)) {
          return;
        }
        const [observer, callback] = node.arguments;
        if (callback) {
          checkCallback(callback);
        } else if (observer && isObjectExpression(observer)) {
          const errorProperty = observer.properties.find(
            (property) => isProperty(property) && isIdentifier(property.key) && property.key.name === "error"
          );
          if (errorProperty) {
            checkCallback(errorProperty.value);
          }
        }
      }
    };
  }
});

// packages/eslint-plugin-rxjs/src/lib/rules/no-index.ts
var import_utils27 = require("@typescript-eslint/utils");
var messageId18 = "forbidden";
var no_index_default = import_utils27.ESLintUtils.RuleCreator(
  () => "https://github.com/DaveMBush/eslint-plugin-rxjs/blob/main/packages/eslint-plugin-rxjs/docs/rules/no-index.md"
)({
  meta: {
    docs: {
      description: "Forbids the importation from index modules."
    },
    fixable: void 0,
    hasSuggestions: false,
    messages: {
      [messageId18]: "RxJS imports from index modules are forbidden."
    },
    schema: [],
    type: "problem"
  },
  name: "no-index",
  defaultOptions: [],
  create: (context) => {
    return {
      [String.raw`ImportDeclaration Literal[value=/^rxjs(?:\u002f\w+)?\u002findex/]`]: (node) => {
        context.report({
          messageId: messageId18,
          node
        });
      }
    };
  }
});

// packages/eslint-plugin-rxjs/src/lib/rules/no-internal.ts
var import_utils28 = require("@typescript-eslint/utils");
var forbiddenId2 = "forbidden";
var suggestId = "suggest";
var no_internal_default = import_utils28.ESLintUtils.RuleCreator(
  () => "https://github.com/DaveMBush/eslint-plugin-rxjs/blob/main/packages/eslint-plugin-rxjs/docs/rules/no-internal.md"
)({
  meta: {
    docs: {
      description: "Forbids the importation of internals."
    },
    fixable: "code",
    hasSuggestions: true,
    messages: {
      [forbiddenId2]: "RxJS imports from internal are forbidden.",
      [suggestId]: "Import from a non-internal location."
    },
    schema: [],
    type: "problem"
  },
  name: "no-internal",
  defaultOptions: [],
  create: (context) => {
    function getReplacement(location) {
      const match = location.match(/^\s*('|")/);
      if (!match) {
        return void 0;
      }
      const [, quote] = match;
      if (/^['"]rxjs\/internal\/ajax/.test(location)) {
        return `${quote}rxjs/ajax${quote}`;
      }
      if (/^['"]rxjs\/internal\/observable\/dom\/fetch/.test(location)) {
        return `${quote}rxjs/fetch${quote}`;
      }
      if (/^['"]rxjs\/internal\/observable\/dom\/webSocket/i.test(location)) {
        return `${quote}rxjs/webSocket${quote}`;
      }
      if (/^['"]rxjs\/internal\/observable/.test(location)) {
        return `${quote}rxjs${quote}`;
      }
      if (/^['"]rxjs\/internal\/operators/.test(location)) {
        return `${quote}rxjs/operators${quote}`;
      }
      if (/^['"]rxjs\/internal\/scheduled/.test(location)) {
        return `${quote}rxjs${quote}`;
      }
      if (/^['"]rxjs\/internal\/scheduler/.test(location)) {
        return `${quote}rxjs${quote}`;
      }
      if (/^['"]rxjs\/internal\/testing/.test(location)) {
        return `${quote}rxjs/testing${quote}`;
      }
      return void 0;
    }
    return {
      [String.raw`ImportDeclaration Literal[value=/^rxjs\u002finternal/]`]: (node) => {
        const replacement = getReplacement(node.raw);
        if (replacement) {
          let fix2 = function(fixer) {
            return fixer.replaceText(node, replacement);
          };
          var fix = fix2;
          context.report({
            fix: fix2,
            messageId: forbiddenId2,
            node,
            suggest: [{ fix: fix2, messageId: suggestId }]
          });
        } else {
          context.report({
            messageId: forbiddenId2,
            node
          });
        }
      }
    };
  }
});

// packages/eslint-plugin-rxjs/src/lib/rules/no-nested-subscribe.ts
var import_utils29 = require("@typescript-eslint/utils");
var messageId19 = "forbidden";
var no_nested_subscribe_default = import_utils29.ESLintUtils.RuleCreator(
  () => "https://github.com/DaveMBush/eslint-plugin-rxjs/blob/main/packages/eslint-plugin-rxjs/docs/rules/no-nested-subscribe.md"
)({
  meta: {
    docs: {
      description: "Forbids the calling of `subscribe` within a `subscribe` callback."
    },
    fixable: void 0,
    hasSuggestions: false,
    messages: {
      [messageId19]: "Nested subscribe calls are forbidden."
    },
    schema: [],
    type: "problem"
  },
  name: "no-nested-subscribe",
  defaultOptions: [],
  create: (context) => {
    const { couldBeObservable, couldBeType: couldBeType2 } = getTypeServices(context);
    const argumentsMap = /* @__PURE__ */ new WeakMap();
    return {
      [`CallExpression > MemberExpression[property.name='subscribe']`]: (node) => {
        if (!couldBeObservable(node.object) && !couldBeType2(node.object, "Subscribable")) {
          return;
        }
        const callExpression = getParent(node);
        let parent = getParent(callExpression);
        while (parent) {
          if (argumentsMap.has(parent)) {
            context.report({
              messageId: messageId19,
              node: node.property
            });
            return;
          }
          parent = getParent(parent);
        }
        for (const arg of callExpression.arguments) {
          argumentsMap.set(arg);
        }
      }
    };
  }
});

// packages/eslint-plugin-rxjs/src/lib/rules/no-redundant-notify.ts
var import_utils30 = require("@typescript-eslint/utils");
var messageId20 = "forbidden";
var no_redundant_notify_default = import_utils30.ESLintUtils.RuleCreator(
  () => "https://github.com/DaveMBush/eslint-plugin-rxjs/blob/main/packages/eslint-plugin-rxjs/docs/rules/no-redundant-notify.md"
)({
  meta: {
    docs: {
      description: "Forbids redundant notifications from completed or errored observables."
    },
    fixable: void 0,
    hasSuggestions: false,
    messages: {
      [messageId20]: "Redundant notifications are forbidden."
    },
    schema: [],
    type: "problem"
  },
  name: "no-redundant-notify",
  defaultOptions: [],
  create: (context) => {
    const sourceCode = context.sourceCode;
    const { couldBeType: couldBeType2 } = getTypeServices(context);
    return {
      "ExpressionStatement[expression.callee.property.name=/^(complete|error)$/] + ExpressionStatement[expression.callee.property.name=/^(next|complete|error)$/]": (node) => {
        const parent = getParent(node);
        if (!parent) {
          return;
        }
        if (!isBlockStatement(parent) && !isProgram(parent)) {
          return;
        }
        const { body } = parent;
        const index = body.indexOf(node);
        const sibling = body[index - 1];
        if (getExpressionText(sibling, sourceCode) !== getExpressionText(node, sourceCode)) {
          return;
        }
        if (!isExpressionObserver(sibling, couldBeType2) || !isExpressionObserver(node, couldBeType2)) {
          return;
        }
        const { expression } = node;
        if (isCallExpression(expression)) {
          const { callee } = expression;
          if (isMemberExpression(callee)) {
            const { property } = callee;
            if (isIdentifier(property)) {
              context.report({
                messageId: messageId20,
                node: property
              });
            }
          }
        }
      }
    };
  }
});
function getExpressionText(expressionStatement, sourceCode) {
  if (!isCallExpression(expressionStatement.expression)) {
    return void 0;
  }
  const callExpression = expressionStatement.expression;
  if (!isMemberExpression(callExpression.callee)) {
    return void 0;
  }
  const { object } = callExpression.callee;
  return sourceCode.getText(object);
}
function isExpressionObserver(expressionStatement, couldBeType2) {
  if (!isCallExpression(expressionStatement.expression)) {
    return false;
  }
  const callExpression = expressionStatement.expression;
  if (!isMemberExpression(callExpression.callee)) {
    return false;
  }
  const { object } = callExpression.callee;
  return couldBeType2(object, /^(Subject|Subscriber)$/);
}

// packages/eslint-plugin-rxjs/src/lib/rules/no-sharereplay.ts
var import_utils31 = require("@typescript-eslint/utils");
var defaultOptions7 = [];
var no_sharereplay_default = import_utils31.ESLintUtils.RuleCreator(
  () => "https://github.com/DaveMBush/eslint-plugin-rxjs/blob/main/packages/eslint-plugin-rxjs/docs/rules/no-sharereplay.md"
)({
  meta: {
    docs: {
      description: "Forbids using the `shareReplay` operator."
    },
    fixable: void 0,
    hasSuggestions: false,
    messages: {
      forbidden: "shareReplay is forbidden.",
      forbiddenWithoutConfig: "shareReplay is forbidden unless a config argument is passed."
    },
    schema: [
      {
        properties: {
          allowConfig: { type: "boolean" }
        },
        type: "object"
      }
    ],
    type: "problem"
  },
  name: "no-sharereplay",
  defaultOptions: defaultOptions7,
  create: (context) => {
    const [config = {}] = context.options;
    const { allowConfig = true } = config;
    return {
      "CallExpression[callee.name='shareReplay']": (node) => {
        let report = true;
        if (allowConfig) {
          report = node.arguments.length !== 1 || node.arguments[0].type !== "ObjectExpression";
        }
        if (report) {
          context.report({
            messageId: allowConfig ? "forbiddenWithoutConfig" : "forbidden",
            node: node.callee
          });
        }
      }
    };
  }
});

// packages/eslint-plugin-rxjs/src/lib/rules/no-subclass.ts
var import_utils32 = require("@typescript-eslint/utils");
var no_subclass_default = import_utils32.ESLintUtils.RuleCreator(
  () => "https://github.com/DaveMBush/eslint-plugin-rxjs/blob/main/packages/eslint-plugin-rxjs/docs/rules/no-subclass.md"
)({
  meta: {
    docs: {
      description: "Forbids sub-classing RxJS classes."
    },
    fixable: void 0,
    hasSuggestions: false,
    messages: {
      forbidden: "Sub-classing RxJS classes is forbidden."
    },
    schema: [],
    type: "problem"
  },
  name: "no-subclass",
  defaultOptions: [],
  create: (context) => {
    const { couldBeType: couldBeType2 } = getTypeServices(context);
    const queryNames = [
      "AsyncSubject",
      "BehaviorSubject",
      "Observable",
      "ReplaySubject",
      "Scheduler",
      "Subject",
      "Subscriber"
    ];
    return {
      [`ClassDeclaration[superClass.name=/^(${queryNames.join(
        "|"
      )})$/] > Identifier.superClass`]: (node) => {
        if (queryNames.some(
          (name2) => couldBeType2(node, name2, { name: /[/\\]rxjs[/\\]/ })
        )) {
          context.report({
            messageId: "forbidden",
            node
          });
        }
      }
    };
  }
});

// packages/eslint-plugin-rxjs/src/lib/rules/no-subject-unsubscribe.ts
var import_utils33 = require("@typescript-eslint/utils");
var messageId21 = "forbidden";
var no_subject_unsubscribe_default = import_utils33.ESLintUtils.RuleCreator(
  () => "https://github.com/DaveMBush/eslint-plugin-rxjs/blob/main/packages/eslint-plugin-rxjs/docs/rules/no-subject-unsubscribe.md"
)({
  meta: {
    docs: {
      description: "Forbids calling the `unsubscribe` method of a subject instance."
    },
    fixable: void 0,
    hasSuggestions: false,
    messages: {
      [messageId21]: "Calling unsubscribe on a subject is forbidden."
    },
    schema: [],
    type: "problem"
  },
  name: "no-subject-unsubscribe",
  defaultOptions: [],
  create: (context) => {
    const { couldBeSubject, couldBeSubscription } = getTypeServices(context);
    return {
      "MemberExpression[property.name='unsubscribe']": (node) => {
        if (couldBeSubject(node.object)) {
          context.report({
            messageId: messageId21,
            node: node.property
          });
        }
      },
      "CallExpression[callee.property.name='add'][arguments.length > 0]": (node) => {
        const memberExpression = node.callee;
        if (couldBeSubscription(memberExpression.object)) {
          const [arg] = node.arguments;
          if (couldBeSubject(arg)) {
            context.report({
              messageId: messageId21,
              node: arg
            });
          }
        }
      }
    };
  }
});

// packages/eslint-plugin-rxjs/src/lib/rules/no-subject-value.ts
var import_utils34 = require("@typescript-eslint/utils");
var messageId22 = "forbidden";
var no_subject_value_default = import_utils34.ESLintUtils.RuleCreator(
  () => "https://github.com/DaveMBush/eslint-plugin-rxjs/blob/main/packages/eslint-plugin-rxjs/docs/rules/no-subject-value.md"
)({
  meta: {
    docs: {
      description: "Forbids accessing the `value` property of a `BehaviorSubject` instance."
    },
    fixable: void 0,
    hasSuggestions: false,
    messages: {
      [messageId22]: "Accessing the value property of a BehaviorSubject is forbidden."
    },
    schema: [],
    type: "problem"
  },
  name: "no-subject-value",
  defaultOptions: [],
  create: (context) => {
    const { couldBeBehaviorSubject } = getTypeServices(context);
    return {
      "Identifier[name=/^(value|getValue)$/]": (node) => {
        const parent = getParent(node);
        if (!parent || !("object" in parent)) {
          return;
        }
        if (couldBeBehaviorSubject(parent.object)) {
          context.report({
            messageId: messageId22,
            node
          });
        }
      }
    };
  }
});

// packages/eslint-plugin-rxjs/src/lib/rules/no-subscribe-handlers.ts
var import_utils35 = require("@typescript-eslint/utils");
var no_subscribe_handlers_default = import_utils35.ESLintUtils.RuleCreator(
  () => "https://github.com/DaveMBush/eslint-plugin-rxjs/blob/main/packages/eslint-plugin-rxjs/docs/rules/no-subscribe-handlers.md"
)({
  meta: {
    docs: {
      description: "Forbids the passing of handlers to `subscribe`."
    },
    fixable: void 0,
    hasSuggestions: false,
    messages: {
      forbidden: "Passing handlers to subscribe is forbidden."
    },
    schema: [],
    type: "problem"
  },
  name: "no-subscribe-handlers",
  defaultOptions: [],
  create: (context) => {
    const { couldBeObservable, couldBeType: couldBeType2 } = getTypeServices(context);
    return {
      "CallExpression[arguments.length > 0][callee.property.name='subscribe']": (node) => {
        const callee = node.callee;
        if (couldBeObservable(callee.object) || couldBeType2(callee.object, "Subscribable")) {
          context.report({
            messageId: "forbidden",
            node: callee.property
          });
        }
      }
    };
  }
});

// packages/eslint-plugin-rxjs/src/lib/rules/no-tap.ts
var import_utils36 = require("@typescript-eslint/utils");
var messageId23 = "forbidden";
var no_tap_default = import_utils36.ESLintUtils.RuleCreator(
  () => "https://github.com/DaveMBush/eslint-plugin-rxjs/blob/main/packages/eslint-plugin-rxjs/docs/rules/no-tap.md"
)({
  meta: {
    deprecated: true,
    docs: {
      description: "Forbids the use of the `tap` operator."
    },
    fixable: void 0,
    hasSuggestions: false,
    messages: {
      [messageId23]: "The tap operator is forbidden."
    },
    replacedBy: ["ban-operators"],
    schema: [],
    type: "problem"
  },
  name: "no-tap",
  defaultOptions: [],
  create: (context) => {
    return {
      [String.raw`ImportDeclaration[source.value=/^rxjs(\u002foperators)?$/] > ImportSpecifier[imported.name='tap']`]: (node) => {
        const { loc } = node;
        context.report({
          messageId: messageId23,
          loc: {
            ...loc,
            end: {
              ...loc.start,
              column: loc.start.column + 3
            }
          }
        });
      }
    };
  }
});

// packages/eslint-plugin-rxjs/src/lib/rules/no-topromise.ts
var import_utils37 = require("@typescript-eslint/utils");
var messageId24 = "forbidden";
var no_topromise_default = import_utils37.ESLintUtils.RuleCreator(
  () => "https://github.com/DaveMBush/eslint-plugin-rxjs/blob/main/packages/eslint-plugin-rxjs/docs/rules/no-topromise.md"
)({
  meta: {
    docs: {
      description: "Forbids the use of the `toPromise` method."
    },
    fixable: void 0,
    hasSuggestions: false,
    messages: {
      [messageId24]: "The toPromise method is forbidden."
    },
    schema: [],
    type: "problem"
  },
  name: "no-topromise",
  defaultOptions: [],
  create: (context) => {
    const { couldBeObservable } = getTypeServices(context);
    return {
      [`MemberExpression[property.name="toPromise"]`]: (node) => {
        if (couldBeObservable(node.object)) {
          context.report({
            messageId: messageId24,
            node: node.property
          });
        }
      }
    };
  }
});

// packages/eslint-plugin-rxjs/src/lib/rules/no-unbound-methods.ts
var import_utils38 = require("@typescript-eslint/utils");
var messageId25 = "forbidden";
var no_unbound_methods_default = import_utils38.ESLintUtils.RuleCreator(
  () => "https://github.com/DaveMBush/eslint-plugin-rxjs/blob/main/packages/eslint-plugin-rxjs/docs/rules/no-unbound-methods.md"
)({
  meta: {
    docs: {
      description: "Forbids the passing of unbound methods."
    },
    fixable: void 0,
    hasSuggestions: false,
    messages: {
      [messageId25]: "Unbound methods are forbidden."
    },
    schema: [],
    type: "problem"
  },
  name: "no-unbound-methods",
  defaultOptions: [],
  create: (context) => {
    const { couldBeObservable, couldBeSubscription, getType } = getTypeServices(context);
    const nodeMap = /* @__PURE__ */ new WeakMap();
    function mapArguments(node) {
      node.arguments.filter(isMemberExpression).forEach((arg) => {
        const argType = getType(arg);
        if (argType && argType.getCallSignatures().length > 0) {
          nodeMap.set(arg);
        }
      });
    }
    function isObservableOrSubscription(node, action) {
      if (!isMemberExpression(node.callee)) {
        return;
      }
      if (couldBeObservable(node.callee.object) || couldBeSubscription(node.callee.object)) {
        action(node);
      }
    }
    return {
      "CallExpression[callee.property.name='pipe']": (node) => {
        isObservableOrSubscription(node, ({ arguments: args }) => {
          args.filter(isCallExpression).forEach(mapArguments);
        });
      },
      "CallExpression[callee.property.name=/^(add|subscribe)$/]": (node) => {
        isObservableOrSubscription(node, mapArguments);
      },
      "NewExpression[callee.name='Subscription']": mapArguments,
      ThisExpression: (node) => {
        let parent = getParent(node);
        while (parent) {
          if (nodeMap.has(parent)) {
            context.report({
              messageId: messageId25,
              node: parent
            });
            return;
          }
          parent = getParent(parent);
        }
      }
    };
  }
});

// packages/eslint-plugin-rxjs/src/lib/rules/no-unsafe-catch.ts
var import_utils39 = require("@typescript-eslint/utils");
var defaultOptions8 = [];
var messageId26 = "forbidden";
var no_unsafe_catch_default = import_utils39.ESLintUtils.RuleCreator(
  () => "https://github.com/DaveMBush/eslint-plugin-rxjs/blob/main/packages/eslint-plugin-rxjs/docs/rules/no-unsafe-catch.md"
)({
  meta: {
    docs: {
      description: "Forbids unsafe `catchError` usage in effects and epics."
    },
    fixable: void 0,
    hasSuggestions: false,
    messages: {
      [messageId26]: "Unsafe catchError usage in effects and epics are forbidden."
    },
    schema: [
      {
        properties: {
          observable: { type: "string" }
        },
        type: "object",
        description: `An optional object with an optional \`observable\` property. The property can be specified as a regular expression string and is used to identify the action observables from which effects and epics are composed.`
      }
    ],
    type: "problem"
  },
  name: "no-unsafe-catch",
  defaultOptions: defaultOptions8,
  create: (context) => {
    const invalidOperatorsRegExp = /^(catchError)$/;
    const [config = {}] = context.options;
    const { observable = defaultObservable } = config;
    const observableRegExp = new RegExp(observable);
    const { couldBeObservable } = getTypeServices(context);
    function isUnsafe([arg]) {
      if (arg && (isFunctionDeclaration(arg) || isArrowFunctionExpression(arg))) {
        return arg.params.length < 2;
      }
      return false;
    }
    function checkNode(node) {
      if (!node.arguments || !couldBeObservable(node)) {
        return;
      }
      node.arguments.forEach((arg) => {
        if (isCallExpression(arg) && isIdentifier(arg.callee)) {
          if (invalidOperatorsRegExp.test(arg.callee.name) && isUnsafe(arg.arguments)) {
            context.report({
              messageId: messageId26,
              node: arg.callee
            });
          }
        }
      });
    }
    return {
      [`CallExpression[callee.property.name='pipe'][callee.object.name=${observableRegExp}]`]: checkNode,
      [`CallExpression[callee.property.name='pipe'][callee.object.property.name=${observableRegExp}]`]: checkNode
    };
  }
});

// packages/eslint-plugin-rxjs/src/lib/rules/no-unsafe-first.ts
var import_utils40 = require("@typescript-eslint/utils");
var defaultOptions9 = [];
var messageId27 = "forbidden";
var no_unsafe_first_default = import_utils40.ESLintUtils.RuleCreator(
  () => "https://github.com/DaveMBush/eslint-plugin-rxjs/blob/main/packages/eslint-plugin-rxjs/docs/rules/no-unsafe-first.md"
)({
  meta: {
    docs: {
      description: "Forbids unsafe `first`/`take` usage in effects and epics."
    },
    fixable: void 0,
    hasSuggestions: false,
    messages: {
      [messageId27]: "Unsafe first and take usage in effects and epics are forbidden."
    },
    schema: [
      {
        properties: {
          observable: { type: "string" }
        },
        type: "object",
        description: `An optional object with an optional \`observable\` property. The property can be specified as a regular expression string and is used to identify the action observables from which effects and epics are composed.`
      }
    ],
    type: "problem"
  },
  name: "no-unsafe-first",
  defaultOptions: defaultOptions9,
  create: (context) => {
    const invalidOperatorsRegExp = /^(take|first)$/;
    const [config = {}] = context.options;
    const { observable = defaultObservable } = config;
    const observableRegExp = new RegExp(observable);
    const { couldBeObservable } = getTypeServices(context);
    const nodes = [];
    function checkNode(node) {
      if (!node.arguments || !couldBeObservable(node)) {
        return;
      }
      node.arguments.forEach((arg) => {
        if (isCallExpression(arg) && isIdentifier(arg.callee)) {
          if (invalidOperatorsRegExp.test(arg.callee.name)) {
            context.report({
              messageId: messageId27,
              node: arg.callee
            });
          }
        }
      });
    }
    return {
      [`CallExpression[callee.property.name='pipe'][callee.object.name=${observableRegExp}]`]: (node) => {
        if (nodes.push(node) === 1) {
          checkNode(node);
        }
      },
      [`CallExpression[callee.property.name='pipe'][callee.object.name=${observableRegExp}]:exit`]: () => {
        nodes.pop();
      },
      [`CallExpression[callee.property.name='pipe'][callee.object.property.name=${observableRegExp}]`]: (node) => {
        if (nodes.push(node) === 1) {
          checkNode(node);
        }
      },
      [`CallExpression[callee.property.name='pipe'][callee.object.property.name=${observableRegExp}]:exit`]: () => {
        nodes.pop();
      }
    };
  }
});

// packages/eslint-plugin-rxjs/src/lib/rules/no-unsafe-subject-next.ts
var tsutils6 = __toESM(require("ts-api-utils"));
var ts11 = __toESM(require("typescript"));
var import_utils41 = require("@typescript-eslint/utils");
var no_unsafe_subject_next_default = import_utils41.ESLintUtils.RuleCreator(
  () => "https://github.com/DaveMBush/eslint-plugin-rxjs/blob/main/packages/eslint-plugin-rxjs/docs/rules/no-unsafe-subject-next.md"
)({
  meta: {
    docs: {
      description: "Forbids unsafe optional `next` calls."
    },
    fixable: void 0,
    hasSuggestions: false,
    messages: {
      forbidden: "Unsafe optional next calls are forbidden."
    },
    schema: [],
    type: "problem"
  },
  name: "no-unsafe-subject-next",
  defaultOptions: [],
  create: (context) => {
    const { esTreeNodeToTSNodeMap } = getParserServices(context);
    const { typeChecker } = getTypeServices(context);
    return {
      [`CallExpression[callee.property.name='next']`]: (node) => {
        if (node.arguments.length === 0 && isMemberExpression(node.callee)) {
          const type = typeChecker.getTypeAtLocation(
            esTreeNodeToTSNodeMap.get(node.callee.object)
          );
          if (isReferenceType(type) && couldBeType(type, "Subject")) {
            const [typeArg] = typeChecker.getTypeArguments(type);
            if (tsutils6.isTypeFlagSet(typeArg, ts11.TypeFlags.Any)) {
              return;
            }
            if (tsutils6.isTypeFlagSet(typeArg, ts11.TypeFlags.Unknown)) {
              return;
            }
            if (tsutils6.isTypeFlagSet(typeArg, ts11.TypeFlags.Void)) {
              return;
            }
            if (isUnionType(typeArg) && typeArg.types.some(
              (t) => tsutils6.isTypeFlagSet(t, ts11.TypeFlags.Void)
            )) {
              return;
            }
            context.report({
              messageId: "forbidden",
              node: node.callee.property
            });
          }
        }
      }
    };
  }
});

// packages/eslint-plugin-rxjs/src/lib/utils.ts
function createRegExpForWords(config) {
  if (!config || !config.length) {
    return void 0;
  }
  const flags = "i";
  if (typeof config === "string") {
    return new RegExp(config, flags);
  }
  const words = config;
  const joined = words.map((word) => String.raw`(\b|_)${word}(\b|_)`).join("|");
  return new RegExp(`(${joined})`, flags);
}
function escapeRegExp(text) {
  return text.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
}

// packages/eslint-plugin-rxjs/src/lib/rules/no-unsafe-switchmap.ts
var import_utils43 = require("@typescript-eslint/utils");
var defaultOptions10 = [];
var messageId28 = "forbidden";
var no_unsafe_switchmap_default = import_utils43.ESLintUtils.RuleCreator(
  () => "https://github.com/DaveMBush/eslint-plugin-rxjs/blob/main/packages/eslint-plugin-rxjs/docs/rules/no-unsafe-switchmap.md"
)({
  meta: {
    docs: {
      description: "Forbids unsafe `switchMap` usage in effects and epics."
    },
    fixable: void 0,
    hasSuggestions: false,
    messages: {
      [messageId28]: "Unsafe switchMap usage in effects and epics is forbidden."
    },
    schema: [
      {
        properties: {
          allow: {
            oneOf: [
              { type: "string" },
              { type: "array", items: { type: "string" } }
            ]
          },
          disallow: {
            oneOf: [
              { type: "string" },
              { type: "array", items: { type: "string" } }
            ]
          },
          observable: {
            oneOf: [
              { type: "string" },
              { type: "array", items: { type: "string" } }
            ]
          }
        },
        type: "object",
        description: `An optional object with optional \`allow\`, \`disallow\` and \`observable\` properties. The properties can be specified as regular expression strings or as arrays of words. The \`allow\` or \`disallow\` properties are mutually exclusive. Whether or not \`switchMap\` is allowed will depend upon the matching of action types with \`allow\` or \`disallow\`. The \`observable\` property is used to identify the action observables from which effects and epics are composed.`
      }
    ],
    type: "problem"
  },
  name: "no-unsafe-switchmap",
  defaultOptions: defaultOptions10,
  create: (context) => {
    const defaultDisallow = [
      "add",
      "create",
      "delete",
      "post",
      "put",
      "remove",
      "set",
      "update"
    ];
    let allowRegExp;
    let disallowRegExp;
    let observableRegExp;
    const [config = {}] = context.options;
    if (config.allow || config.disallow) {
      allowRegExp = createRegExpForWords(config.allow ?? []);
      disallowRegExp = createRegExpForWords(config.disallow ?? []);
      observableRegExp = new RegExp(config.observable ?? defaultObservable);
    } else {
      allowRegExp = void 0;
      disallowRegExp = createRegExpForWords(defaultDisallow);
      observableRegExp = new RegExp(defaultObservable);
    }
    const { couldBeObservable } = getTypeServices(context);
    function decamelize(str) {
      return str.replace(/([a-z\d])([A-Z])/g, "$1_$2").replace(/([A-Z]+)([A-Z][a-z\d]+)/g, "$1_$2").toLowerCase();
    }
    function shouldDisallow(args) {
      const names = args.map((arg) => {
        if (isLiteral(arg) && typeof arg.value === "string") {
          return arg.value;
        }
        if (isIdentifier(arg)) {
          return arg.name;
        }
        if (isMemberExpression(arg) && isIdentifier(arg.property)) {
          return arg.property.name;
        }
        return "";
      }).map((name2) => decamelize(name2));
      if (allowRegExp) {
        return !names.every((name2) => allowRegExp?.test(name2));
      }
      if (disallowRegExp) {
        return names.some((name2) => disallowRegExp?.test(name2));
      }
      return false;
    }
    function checkNode(node) {
      if (!node.arguments || !couldBeObservable(node)) {
        return;
      }
      const hasUnsafeOfType = node.arguments.some((arg) => {
        if (isCallExpression(arg) && isIdentifier(arg.callee) && arg.callee.name === "ofType") {
          return shouldDisallow(arg.arguments);
        }
        return false;
      });
      if (!hasUnsafeOfType) {
        return;
      }
      node.arguments.forEach((arg) => {
        if (isCallExpression(arg) && isIdentifier(arg.callee) && arg.callee.name === "switchMap") {
          context.report({
            messageId: messageId28,
            node: arg.callee
          });
        }
      });
    }
    return {
      [`CallExpression[callee.property.name='pipe'][callee.object.name=${observableRegExp}]`]: checkNode,
      [`CallExpression[callee.property.name='pipe'][callee.object.property.name=${observableRegExp}]`]: checkNode
    };
  }
});

// packages/eslint-plugin-rxjs/src/lib/rules/no-unsafe-takeuntil.ts
var import_utils44 = require("@typescript-eslint/utils");
var defaultOptions11 = [];
var messageId29 = "forbidden";
var no_unsafe_takeuntil_default = import_utils44.ESLintUtils.RuleCreator(
  () => "https://github.com/DaveMBush/eslint-plugin-rxjs/blob/main/packages/eslint-plugin-rxjs/docs/rules/no-unsafe-takeuntil.md"
)({
  meta: {
    docs: {
      description: "Forbids the application of operators after `takeUntil`."
    },
    fixable: void 0,
    hasSuggestions: false,
    messages: {
      [messageId29]: "Applying operators after takeUntil is forbidden."
    },
    schema: [
      {
        properties: {
          alias: { type: "array", items: { type: "string" } },
          allow: { type: "array", items: { type: "string" } }
        },
        type: "object",
        description: `An optional object with optional \`alias\` and \`allow\` properties. The \`alias\` property is an array containing the names of operators that aliases for \`takeUntil\`. The \`allow\` property is an array containing the names of the operators that are allowed to follow \`takeUntil\`.`
      }
    ],
    type: "problem"
  },
  name: "no-unsafe-takeuntil",
  defaultOptions: defaultOptions11,
  create: (context) => {
    let checkedOperatorsRegExp = /^takeUntil$/;
    const allowedOperators = [
      "count",
      "defaultIfEmpty",
      "endWith",
      "every",
      "finalize",
      "finally",
      "isEmpty",
      "last",
      "max",
      "min",
      "publish",
      "publishBehavior",
      "publishLast",
      "publishReplay",
      "reduce",
      "share",
      "shareReplay",
      "skipLast",
      "takeLast",
      "throwIfEmpty",
      "toArray"
    ];
    const [config = {}] = context.options;
    const { alias, allow = allowedOperators } = config;
    if (alias) {
      checkedOperatorsRegExp = new RegExp(
        `^(${alias.concat("takeUntil").join("|")})$`
      );
    }
    const { couldBeObservable } = getTypeServices(context);
    function checkNode(node) {
      const pipeCallExpression = getParent(node);
      if (!pipeCallExpression.arguments || !couldBeObservable(pipeCallExpression)) {
        return;
      }
      pipeCallExpression.arguments.reduceRight((state, arg) => {
        if (state === "taken") {
          return state;
        }
        if (!isCallExpression(arg)) {
          return "disallowed";
        }
        let operatorName;
        if (isIdentifier(arg.callee)) {
          operatorName = arg.callee.name;
        } else if (isMemberExpression(arg.callee) && isIdentifier(arg.callee.property)) {
          operatorName = arg.callee.property.name;
        } else {
          return "disallowed";
        }
        if (checkedOperatorsRegExp.test(operatorName)) {
          if (state === "disallowed") {
            context.report({
              messageId: messageId29,
              node: arg.callee
            });
          }
          return "taken";
        }
        if (!allow.includes(operatorName)) {
          return "disallowed";
        }
        return state;
      }, "allowed");
    }
    return {
      [`CallExpression[callee.property.name='pipe'] > CallExpression[callee.name=${checkedOperatorsRegExp}]`]: checkNode,
      [`CallExpression[callee.property.name='pipe'] > CallExpression[callee.property.name=${checkedOperatorsRegExp}]`]: checkNode
    };
  }
});

// packages/eslint-plugin-rxjs/src/lib/rules/prefer-observer.ts
var import_utils45 = require("@typescript-eslint/utils");
var defaultOptions12 = [];
var messageId30 = "forbidden";
var prefer_observer_default = import_utils45.ESLintUtils.RuleCreator(
  () => "https://github.com/DaveMBush/eslint-plugin-rxjs/blob/main/packages/eslint-plugin-rxjs/docs/rules/prefer-observer.md"
)({
  meta: {
    docs: {
      description: "Forbids the passing separate handlers to `subscribe` and `tap`."
    },
    fixable: "code",
    hasSuggestions: true,
    messages: {
      [messageId30]: "Passing separate handlers is forbidden; pass an observer instead."
    },
    schema: [
      {
        properties: {
          allowNext: { type: "boolean" }
        },
        type: "object"
      }
    ],
    type: "problem"
  },
  name: "prefer-observer",
  defaultOptions: defaultOptions12,
  create: (context) => {
    const { couldBeFunction: couldBeFunction2, couldBeObservable } = getTypeServices(context);
    const [config = {}] = context.options;
    const { allowNext = true } = config;
    function checkArgs(callExpression, reportNode) {
      const { arguments: args, callee } = callExpression;
      if (isMemberExpression(callee) && !couldBeObservable(callee.object)) {
        return;
      }
      function* fix(fixer) {
        const sourceCode = context.sourceCode;
        const [nextArg, errorArg, completeArg] = args;
        const nextArgText = nextArg ? sourceCode.getText(nextArg) : "";
        const errorArgText = errorArg ? sourceCode.getText(errorArg) : "";
        const completeArgText = completeArg ? sourceCode.getText(completeArg) : "";
        let observer = "{";
        if (nextArgText && nextArgText !== "undefined" && nextArgText !== "null") {
          observer += ` next: ${nextArgText}${isValidArgText(errorArgText) || isValidArgText(completeArgText) ? "," : ""}`;
        }
        if (errorArgText && errorArgText !== "undefined" && errorArgText !== "null") {
          observer += ` error: ${errorArgText}${isValidArgText(completeArgText) ? "," : ""}`;
        }
        if (completeArgText && completeArgText !== "undefined" && completeArgText !== "null") {
          observer += ` complete: ${completeArgText}`;
        }
        observer += " }";
        yield fixer.replaceText(callExpression.arguments[0], observer);
        const [, start] = callExpression.arguments[0].range;
        const [, end] = callExpression.arguments[callExpression.arguments.length - 1].range;
        yield fixer.removeRange([start, end]);
      }
      if (args.length > 1) {
        context.report({
          messageId: messageId30,
          node: reportNode,
          fix,
          suggest: [
            {
              messageId: messageId30,
              fix
            }
          ]
        });
      } else if (args.length === 1 && !allowNext) {
        const [arg] = args;
        if (isArrowFunctionExpression(arg) || isFunctionExpression(arg) || couldBeFunction2(arg)) {
          context.report({
            messageId: messageId30,
            node: reportNode,
            fix,
            suggest: [
              {
                messageId: messageId30,
                fix
              }
            ]
          });
        }
      }
    }
    return {
      "CallExpression[callee.property.name='pipe'] > CallExpression[callee.name='tap']": (node) => checkArgs(node, node.callee),
      "CallExpression[callee.property.name='subscribe']": (node) => checkArgs(node, node.callee.property)
    };
  }
});
function isValidArgText(argText) {
  return argText && argText !== "undefined" && argText !== "null";
}

// packages/eslint-plugin-rxjs/src/lib/rules/suffix-subjects.ts
var import_utils47 = require("@typescript-eslint/utils");
var defaultOptions13 = [];
var messageId31 = "forbidden";
var suffix_subjects_default = import_utils47.ESLintUtils.RuleCreator(
  () => "https://github.com/DaveMBush/eslint-plugin-rxjs/blob/main/packages/eslint-plugin-rxjs/docs/rules/suffix-subjects.md"
)({
  meta: {
    docs: {
      description: "Enforces the use of a suffix in subject identifiers."
    },
    fixable: void 0,
    hasSuggestions: false,
    messages: {
      [messageId31]: `Subject identifiers must end with "{{suffix}}".`
    },
    schema: [
      {
        properties: {
          parameters: { type: "boolean" },
          properties: { type: "boolean" },
          suffix: { type: "string" },
          types: { type: "object" },
          variables: { type: "boolean" }
        },
        type: "object"
      }
    ],
    type: "problem"
  },
  name: "suffix-subjects",
  defaultOptions: defaultOptions13,
  create: (context) => {
    const { esTreeNodeToTSNodeMap } = getParserServices(context);
    const { couldBeType: couldBeType2 } = getTypeServices(context);
    const [config = {}] = context.options;
    const validate = {
      parameters: true,
      properties: true,
      variables: true,
      ...config
    };
    const types = [];
    if (config.types) {
      Object.entries(config.types).forEach(
        ([key, validate2]) => {
          types.push({ regExp: new RegExp(key), validate: validate2 });
        }
      );
    } else {
      types.push({
        regExp: /^EventEmitter$/,
        validate: false
      });
    }
    const { suffix = "Subject" } = config;
    const suffixRegex = new RegExp(
      String.raw`${escapeRegExp(suffix)}\$?$`,
      "i"
    );
    function checkNode(nameNode, typeNode) {
      const tsNode = esTreeNodeToTSNodeMap.get(nameNode);
      const text = tsNode.getText();
      if (!suffixRegex.test(text) && couldBeType2(typeNode || nameNode, "Subject")) {
        for (const type of types) {
          const { regExp, validate: validate2 } = type;
          if (couldBeType2(typeNode || nameNode, regExp) && !validate2) {
            return;
          }
        }
        context.report({
          data: { suffix },
          loc: getLoc(tsNode),
          messageId: messageId31
        });
      }
    }
    return {
      "ArrayPattern > Identifier": (node) => {
        const found = findParent(
          node,
          "ArrowFunctionExpression",
          "FunctionDeclaration",
          "FunctionExpression",
          "VariableDeclarator"
        );
        if (!found) {
          return;
        }
        if (!validate.variables && found.type === "VariableDeclarator") {
          return;
        }
        if (!validate.parameters) {
          return;
        }
        checkNode(node);
      },
      "ArrowFunctionExpression > Identifier": (node) => {
        if (validate.parameters) {
          const parent = getParent(node);
          if (node !== parent.body) {
            checkNode(node);
          }
        }
      },
      "PropertyDefinition[computed=false]": (node) => {
        const anyNode = node;
        if (validate.properties) {
          checkNode(anyNode.key);
        }
      },
      "FunctionDeclaration > Identifier": (node) => {
        if (validate.parameters) {
          const parent = getParent(node);
          if (node !== parent.id) {
            checkNode(node);
          }
        }
      },
      "FunctionExpression > Identifier": (node) => {
        if (validate.parameters) {
          const parent = getParent(node);
          if (node !== parent.id) {
            checkNode(node);
          }
        }
      },
      "MethodDefinition[kind='get'][computed=false]": (node) => {
        if (validate.properties) {
          checkNode(node.key, node);
        }
      },
      "MethodDefinition[kind='set'][computed=false]": (node) => {
        if (validate.properties) {
          checkNode(node.key, node);
        }
      },
      "ObjectExpression > Property[computed=false] > Identifier": (node) => {
        if (validate.properties) {
          const parent = getParent(node);
          if (node === parent.key) {
            checkNode(node);
          }
        }
      },
      "ObjectPattern > Property > Identifier": (node) => {
        const found = findParent(
          node,
          "ArrowFunctionExpression",
          "FunctionDeclaration",
          "FunctionExpression",
          "VariableDeclarator"
        );
        if (!found) {
          return;
        }
        if (!validate.variables && found.type === "VariableDeclarator") {
          return;
        }
        if (!validate.parameters) {
          return;
        }
        const parent = getParent(node);
        if (node === parent.value) {
          checkNode(node);
        }
      },
      "TSCallSignatureDeclaration > Identifier": (node) => {
        if (validate.parameters) {
          checkNode(node);
        }
      },
      "TSConstructSignatureDeclaration > Identifier": (node) => {
        if (validate.parameters) {
          checkNode(node);
        }
      },
      "TSMethodSignature > Identifier": (node) => {
        if (validate.parameters) {
          checkNode(node);
        }
      },
      "TSParameterProperty > Identifier": (node) => {
        if (validate.parameters || validate.properties) {
          checkNode(node);
        }
      },
      "TSPropertySignature[computed=false]": (node) => {
        const anyNode = node;
        if (validate.properties) {
          checkNode(anyNode.key);
        }
      },
      "VariableDeclarator > Identifier": (node) => {
        const parent = getParent(node);
        if (validate.variables && node === parent.id) {
          checkNode(node);
        }
      }
    };
  }
});

// packages/eslint-plugin-rxjs/src/lib/rules/throw-error.ts
var import_utils48 = require("@typescript-eslint/utils");
var messageId32 = "forbidden";
var throw_error_default = import_utils48.ESLintUtils.RuleCreator(
  () => "https://github.com/DaveMBush/eslint-plugin-rxjs/blob/main/packages/eslint-plugin-rxjs/docs/rules/throw-error.md"
)({
  meta: {
    docs: {
      description: "Enforces the passing of `Error` values to error notifications."
    },
    fixable: void 0,
    hasSuggestions: false,
    messages: {
      [messageId32]: "Passing non-Error values are forbidden."
    },
    schema: [],
    type: "problem"
  },
  name: "throw-error",
  defaultOptions: [],
  create: (context) => {
    const { esTreeNodeToTSNodeMap, program } = getParserServices(context);
    const { couldBeObservable, getType } = getTypeServices(context);
    function checkNode(node) {
      let type = getType(node);
      if (type && couldBeFunction(type)) {
        const tsNode = esTreeNodeToTSNodeMap.get(node);
        const annotation = tsNode.type;
        const body = tsNode.body;
        type = program.getTypeChecker().getTypeAtLocation(annotation ?? body);
      }
      if (type && !isAny(type) && !isUnknown(type) && !couldBeType(type, /^(Error|DOMException)$/)) {
        context.report({
          messageId: messageId32,
          node
        });
      }
    }
    return {
      "ThrowStatement > *": checkNode,
      "CallExpression[callee.name='throwError']": (node) => {
        if (couldBeObservable(node)) {
          const [arg] = node.arguments;
          if (arg) {
            checkNode(arg);
          }
        }
      }
    };
  }
});

// packages/eslint-plugin-rxjs/src/index.ts
var { name, version } = require_package();
var meta = {
  name,
  version
};
var rules = {
  "ban-observables": ban_observables_default,
  "ban-operators": ban_operators_default,
  finnish: finnish_default,
  just: just_default,
  macro: macro_default,
  "no-async-subscribe": no_async_subscribe_default,
  "no-compat": no_compat_default,
  "no-connectable": no_connectable_default,
  "no-create": no_create_default,
  "no-cyclic-action": no_cyclic_action_default,
  "no-exposed-subjects": no_exposed_subjects_default,
  "no-finnish": no_finnish_default,
  "no-ignored-error": no_ignored_error_default,
  "no-ignored-notifier": no_ignored_notifier_default,
  "no-ignored-observable": no_ignored_observable_default,
  "no-ignored-replay-buffer": no_ignored_replay_buffer_default,
  "no-ignored-subscribe": no_ignored_subscribe_default,
  "no-ignored-subscription": no_ignored_subscription_default,
  "no-ignored-takewhile-value": no_ignored_takewhile_value_default,
  "no-implicit-any-catch": no_implicit_any_catch_default,
  "no-index": no_index_default,
  "no-internal": no_internal_default,
  "no-nested-subscribe": no_nested_subscribe_default,
  "no-redundant-notify": no_redundant_notify_default,
  "no-sharereplay": no_sharereplay_default,
  "no-subclass": no_subclass_default,
  "no-subject-unsubscribe": no_subject_unsubscribe_default,
  "no-subject-value": no_subject_value_default,
  "no-subscribe-handlers": no_subscribe_handlers_default,
  "no-tap": no_tap_default,
  "no-topromise": no_topromise_default,
  "no-unbound-methods": no_unbound_methods_default,
  "no-unsafe-catch": no_unsafe_catch_default,
  "no-unsafe-first": no_unsafe_first_default,
  "no-unsafe-subject-next": no_unsafe_subject_next_default,
  "no-unsafe-switchmap": no_unsafe_switchmap_default,
  "no-unsafe-takeuntil": no_unsafe_takeuntil_default,
  "prefer-observer": prefer_observer_default,
  "suffix-subjects": suffix_subjects_default,
  "throw-error": throw_error_default
};
var basePlugin = {
  meta,
  rules
};
var recommendedConfig = {
  name: "@smarttools/rxjs/recommended",
  plugins: {
    "@smarttools/rxjs": basePlugin
  },
  rules: {
    ...import_recommended.default.rules
  }
};
var plugin = {
  ...basePlugin,
  configs: {
    recommended: recommendedConfig,
    "recommended-legacy": import_recommended.default
  }
};
module.exports = plugin;
