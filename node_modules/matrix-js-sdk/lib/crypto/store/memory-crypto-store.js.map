{"version":3,"file":"memory-crypto-store.js","names":["_logger","require","_utils","_base","ownKeys","e","r","t","Object","keys","getOwnPropertySymbols","o","filter","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","arguments","length","forEach","_defineProperty2","default","getOwnPropertyDescriptors","defineProperties","defineProperty","encodeSessionKey","senderCurve25519Key","sessionId","encodeURIComponent","decodeSessionKey","key","keyParts","split","senderKey","decodeURIComponent","MemoryCryptoStore","constructor","MigrationState","NOT_STARTED","Map","containsData","account","startup","deleteAllData","Promise","resolve","getMigrationState","migrationState","setMigrationState","getOrAddOutgoingRoomKeyRequest","request","requestBody","promiseTry","existing","_getOutgoingRoomKeyRequest","logger","log","room_id","session_id","outgoingRoomKeyRequests","getOutgoingRoomKeyRequest","deepCompare","getOutgoingRoomKeyRequestByState","wantedStates","req","state","getAllOutgoingRoomKeyRequestsByState","wantedState","getOutgoingRoomKeyRequestsByTarget","userId","deviceId","results","recipients","some","recipient","updateOutgoingRoomKeyRequest","requestId","expectedState","updates","warn","assign","deleteOutgoingRoomKeyRequest","i","splice","getAccount","txn","func","storeAccount","accountPickle","getCrossSigningKeys","crossSigningKeys","getSecretStorePrivateKey","type","result","privateKeys","storeCrossSigningKeys","storeSecretStorePrivateKey","countEndToEndSessions","count","deviceSessions","values","sessions","getEndToEndSession","deviceKey","getEndToEndSessions","getAllEndToEndSessions","entries","session","storeEndToEndSession","sessionInfo","undefined","safeSet","storeEndToEndSessionProblem","fixed","problems","sessionProblems","time","Date","now","sort","a","b","getEndToEndSessionProblem","timestamp","lastProblem","problem","filterOutNotifiedErrorDevices","devices","notifiedErrorDevices","ret","device","deviceInfo","getEndToEndSessionsBatch","SESSION_BATCH_SIZE","deleteEndToEndSessionsBatch","getEndToEndInboundGroupSession","k","inboundGroupSessions","inboundGroupSessionsWithheld","getAllEndToEndInboundGroupSessions","sessionData","addEndToEndInboundGroupSession","storeEndToEndInboundGroupSession","storeEndToEndInboundGroupSessionWithheld","countEndToEndInboundGroupSessions","getEndToEndInboundGroupSessionsBatch","needsBackup","sessionsNeedingBackup","deleteEndToEndInboundGroupSessionsBatch","getEndToEndDeviceData","deviceData","storeEndToEndDeviceData","storeEndToEndRoom","roomId","roomInfo","rooms","getEndToEndRooms","getSessionsNeedingBackup","limit","countSessionsNeedingBackup","unmarkSessionsNeedingBackup","sessionKey","markSessionsNeedingBackup","addSharedHistoryInboundGroupSession","sharedHistoryInboundGroupSessions","getSharedHistoryInboundGroupSessions","addParkedSharedHistory","parkedData","_this$parkedSharedHis","parked","parkedSharedHistory","get","set","takeParkedSharedHistory","_this$parkedSharedHis2","delete","doTxn","mode","stores","exports"],"sources":["../../../src/crypto/store/memory-crypto-store.ts"],"sourcesContent":["/*\nCopyright 2017 - 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { logger } from \"../../logger\";\nimport { deepCompare, promiseTry, safeSet } from \"../../utils\";\nimport {\n    CryptoStore,\n    IDeviceData,\n    IProblem,\n    ISession,\n    SessionExtended,\n    ISessionInfo,\n    IWithheld,\n    MigrationState,\n    Mode,\n    OutgoingRoomKeyRequest,\n    ParkedSharedHistory,\n    SecretStorePrivateKeys,\n    SESSION_BATCH_SIZE,\n} from \"./base\";\nimport { IRoomKeyRequestBody } from \"../index\";\nimport { ICrossSigningKey } from \"../../client\";\nimport { IOlmDevice } from \"../algorithms/megolm\";\nimport { IRoomEncryption } from \"../RoomList\";\nimport { InboundGroupSessionData } from \"../OlmDevice\";\n\nfunction encodeSessionKey(senderCurve25519Key: string, sessionId: string): string {\n    return encodeURIComponent(senderCurve25519Key) + \"/\" + encodeURIComponent(sessionId);\n}\n\nfunction decodeSessionKey(key: string): { senderKey: string; sessionId: string } {\n    const keyParts = key.split(\"/\");\n    const senderKey = decodeURIComponent(keyParts[0]);\n    const sessionId = decodeURIComponent(keyParts[1]);\n    return { senderKey, sessionId };\n}\n\n/**\n * Internal module. in-memory storage for e2e.\n */\n\nexport class MemoryCryptoStore implements CryptoStore {\n    private migrationState: MigrationState = MigrationState.NOT_STARTED;\n    private outgoingRoomKeyRequests: OutgoingRoomKeyRequest[] = [];\n    private account: string | null = null;\n    private crossSigningKeys: Record<string, ICrossSigningKey> | null = null;\n    private privateKeys: Partial<SecretStorePrivateKeys> = {};\n\n    private sessions: { [deviceKey: string]: { [sessionId: string]: ISessionInfo } } = {};\n    private sessionProblems: { [deviceKey: string]: IProblem[] } = {};\n    private notifiedErrorDevices: { [userId: string]: { [deviceId: string]: boolean } } = {};\n    private inboundGroupSessions: { [sessionKey: string]: InboundGroupSessionData } = {};\n    private inboundGroupSessionsWithheld: Record<string, IWithheld> = {};\n    // Opaque device data object\n    private deviceData: IDeviceData | null = null;\n    private rooms: { [roomId: string]: IRoomEncryption } = {};\n    private sessionsNeedingBackup: { [sessionKey: string]: boolean } = {};\n    private sharedHistoryInboundGroupSessions: { [roomId: string]: [senderKey: string, sessionId: string][] } = {};\n    private parkedSharedHistory = new Map<string, ParkedSharedHistory[]>(); // keyed by room ID\n\n    /**\n     * Returns true if this CryptoStore has ever been initialised (ie, it might contain data).\n     *\n     * Implementation of {@link CryptoStore.containsData}.\n     *\n     * @internal\n     */\n    public async containsData(): Promise<boolean> {\n        // If it contains anything, it should contain an account.\n        return this.account !== null;\n    }\n\n    /**\n     * Ensure the database exists and is up-to-date.\n     *\n     * This must be called before the store can be used.\n     *\n     * @returns resolves to the store.\n     */\n    public async startup(): Promise<CryptoStore> {\n        // No startup work to do for the memory store.\n        return this;\n    }\n\n    /**\n     * Delete all data from this store.\n     *\n     * @returns Promise which resolves when the store has been cleared.\n     */\n    public deleteAllData(): Promise<void> {\n        return Promise.resolve();\n    }\n\n    /**\n     * Get data on how much of the libolm to Rust Crypto migration has been done.\n     *\n     * Implementation of {@link CryptoStore.getMigrationState}.\n     *\n     * @internal\n     */\n    public async getMigrationState(): Promise<MigrationState> {\n        return this.migrationState;\n    }\n\n    /**\n     * Set data on how much of the libolm to Rust Crypto migration has been done.\n     *\n     * Implementation of {@link CryptoStore.setMigrationState}.\n     *\n     * @internal\n     */\n    public async setMigrationState(migrationState: MigrationState): Promise<void> {\n        this.migrationState = migrationState;\n    }\n\n    /**\n     * Look for an existing outgoing room key request, and if none is found,\n     * add a new one\n     *\n     *\n     * @returns resolves to\n     *    {@link OutgoingRoomKeyRequest}: either the\n     *    same instance as passed in, or the existing one.\n     */\n    public getOrAddOutgoingRoomKeyRequest(request: OutgoingRoomKeyRequest): Promise<OutgoingRoomKeyRequest> {\n        const requestBody = request.requestBody;\n\n        return promiseTry(() => {\n            // first see if we already have an entry for this request.\n            const existing = this._getOutgoingRoomKeyRequest(requestBody);\n\n            if (existing) {\n                // this entry matches the request - return it.\n                logger.log(\n                    `already have key request outstanding for ` +\n                        `${requestBody.room_id} / ${requestBody.session_id}: ` +\n                        `not sending another`,\n                );\n                return existing;\n            }\n\n            // we got to the end of the list without finding a match\n            // - add the new request.\n            logger.log(`enqueueing key request for ${requestBody.room_id} / ` + requestBody.session_id);\n            this.outgoingRoomKeyRequests.push(request);\n            return request;\n        });\n    }\n\n    /**\n     * Look for an existing room key request\n     *\n     * @param requestBody - existing request to look for\n     *\n     * @returns resolves to the matching\n     *    {@link OutgoingRoomKeyRequest}, or null if\n     *    not found\n     */\n    public getOutgoingRoomKeyRequest(requestBody: IRoomKeyRequestBody): Promise<OutgoingRoomKeyRequest | null> {\n        return Promise.resolve(this._getOutgoingRoomKeyRequest(requestBody));\n    }\n\n    /**\n     * Looks for existing room key request, and returns the result synchronously.\n     *\n     * @internal\n     *\n     * @param requestBody - existing request to look for\n     *\n     * @returns\n     *    the matching request, or null if not found\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    private _getOutgoingRoomKeyRequest(requestBody: IRoomKeyRequestBody): OutgoingRoomKeyRequest | null {\n        for (const existing of this.outgoingRoomKeyRequests) {\n            if (deepCompare(existing.requestBody, requestBody)) {\n                return existing;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Look for room key requests by state\n     *\n     * @param wantedStates - list of acceptable states\n     *\n     * @returns resolves to the a\n     *    {@link OutgoingRoomKeyRequest}, or null if\n     *    there are no pending requests in those states\n     */\n    public getOutgoingRoomKeyRequestByState(wantedStates: number[]): Promise<OutgoingRoomKeyRequest | null> {\n        for (const req of this.outgoingRoomKeyRequests) {\n            for (const state of wantedStates) {\n                if (req.state === state) {\n                    return Promise.resolve(req);\n                }\n            }\n        }\n        return Promise.resolve(null);\n    }\n\n    /**\n     *\n     * @returns All OutgoingRoomKeyRequests in state\n     */\n    public getAllOutgoingRoomKeyRequestsByState(wantedState: number): Promise<OutgoingRoomKeyRequest[]> {\n        return Promise.resolve(this.outgoingRoomKeyRequests.filter((r) => r.state == wantedState));\n    }\n\n    public getOutgoingRoomKeyRequestsByTarget(\n        userId: string,\n        deviceId: string,\n        wantedStates: number[],\n    ): Promise<OutgoingRoomKeyRequest[]> {\n        const results: OutgoingRoomKeyRequest[] = [];\n\n        for (const req of this.outgoingRoomKeyRequests) {\n            for (const state of wantedStates) {\n                if (\n                    req.state === state &&\n                    req.recipients.some((recipient) => recipient.userId === userId && recipient.deviceId === deviceId)\n                ) {\n                    results.push(req);\n                }\n            }\n        }\n        return Promise.resolve(results);\n    }\n\n    /**\n     * Look for an existing room key request by id and state, and update it if\n     * found\n     *\n     * @param requestId -      ID of request to update\n     * @param expectedState -  state we expect to find the request in\n     * @param updates -        name/value map of updates to apply\n     *\n     * @returns resolves to\n     *    {@link OutgoingRoomKeyRequest}\n     *    updated request, or null if no matching row was found\n     */\n    public updateOutgoingRoomKeyRequest(\n        requestId: string,\n        expectedState: number,\n        updates: Partial<OutgoingRoomKeyRequest>,\n    ): Promise<OutgoingRoomKeyRequest | null> {\n        for (const req of this.outgoingRoomKeyRequests) {\n            if (req.requestId !== requestId) {\n                continue;\n            }\n\n            if (req.state !== expectedState) {\n                logger.warn(\n                    `Cannot update room key request from ${expectedState} ` +\n                        `as it was already updated to ${req.state}`,\n                );\n                return Promise.resolve(null);\n            }\n            Object.assign(req, updates);\n            return Promise.resolve(req);\n        }\n\n        return Promise.resolve(null);\n    }\n\n    /**\n     * Look for an existing room key request by id and state, and delete it if\n     * found\n     *\n     * @param requestId -      ID of request to update\n     * @param expectedState -  state we expect to find the request in\n     *\n     * @returns resolves once the operation is completed\n     */\n    public deleteOutgoingRoomKeyRequest(\n        requestId: string,\n        expectedState: number,\n    ): Promise<OutgoingRoomKeyRequest | null> {\n        for (let i = 0; i < this.outgoingRoomKeyRequests.length; i++) {\n            const req = this.outgoingRoomKeyRequests[i];\n\n            if (req.requestId !== requestId) {\n                continue;\n            }\n\n            if (req.state != expectedState) {\n                logger.warn(`Cannot delete room key request in state ${req.state} ` + `(expected ${expectedState})`);\n                return Promise.resolve(null);\n            }\n\n            this.outgoingRoomKeyRequests.splice(i, 1);\n            return Promise.resolve(req);\n        }\n\n        return Promise.resolve(null);\n    }\n\n    // Olm Account\n\n    public getAccount(txn: unknown, func: (accountPickle: string | null) => void): void {\n        func(this.account);\n    }\n\n    public storeAccount(txn: unknown, accountPickle: string): void {\n        this.account = accountPickle;\n    }\n\n    public getCrossSigningKeys(txn: unknown, func: (keys: Record<string, ICrossSigningKey> | null) => void): void {\n        func(this.crossSigningKeys);\n    }\n\n    public getSecretStorePrivateKey<K extends keyof SecretStorePrivateKeys>(\n        txn: unknown,\n        func: (key: SecretStorePrivateKeys[K] | null) => void,\n        type: K,\n    ): void {\n        const result = this.privateKeys[type] as SecretStorePrivateKeys[K] | undefined;\n        func(result || null);\n    }\n\n    public storeCrossSigningKeys(txn: unknown, keys: Record<string, ICrossSigningKey>): void {\n        this.crossSigningKeys = keys;\n    }\n\n    public storeSecretStorePrivateKey<K extends keyof SecretStorePrivateKeys>(\n        txn: unknown,\n        type: K,\n        key: SecretStorePrivateKeys[K],\n    ): void {\n        this.privateKeys[type] = key;\n    }\n\n    // Olm Sessions\n\n    public countEndToEndSessions(txn: unknown, func: (count: number) => void): void {\n        let count = 0;\n        for (const deviceSessions of Object.values(this.sessions)) {\n            count += Object.keys(deviceSessions).length;\n        }\n        func(count);\n    }\n\n    public getEndToEndSession(\n        deviceKey: string,\n        sessionId: string,\n        txn: unknown,\n        func: (session: ISessionInfo) => void,\n    ): void {\n        const deviceSessions = this.sessions[deviceKey] || {};\n        func(deviceSessions[sessionId] || null);\n    }\n\n    public getEndToEndSessions(\n        deviceKey: string,\n        txn: unknown,\n        func: (sessions: { [sessionId: string]: ISessionInfo }) => void,\n    ): void {\n        func(this.sessions[deviceKey] || {});\n    }\n\n    public getAllEndToEndSessions(txn: unknown, func: (session: ISessionInfo) => void): void {\n        Object.entries(this.sessions).forEach(([deviceKey, deviceSessions]) => {\n            Object.entries(deviceSessions).forEach(([sessionId, session]) => {\n                func({\n                    ...session,\n                    deviceKey,\n                    sessionId,\n                });\n            });\n        });\n    }\n\n    public storeEndToEndSession(deviceKey: string, sessionId: string, sessionInfo: ISessionInfo, txn: unknown): void {\n        let deviceSessions = this.sessions[deviceKey];\n        if (deviceSessions === undefined) {\n            deviceSessions = {};\n            this.sessions[deviceKey] = deviceSessions;\n        }\n        safeSet(deviceSessions, sessionId, sessionInfo);\n    }\n\n    public async storeEndToEndSessionProblem(deviceKey: string, type: string, fixed: boolean): Promise<void> {\n        const problems = (this.sessionProblems[deviceKey] = this.sessionProblems[deviceKey] || []);\n        problems.push({ type, fixed, time: Date.now() });\n        problems.sort((a, b) => {\n            return a.time - b.time;\n        });\n    }\n\n    public async getEndToEndSessionProblem(deviceKey: string, timestamp: number): Promise<IProblem | null> {\n        const problems = this.sessionProblems[deviceKey] || [];\n        if (!problems.length) {\n            return null;\n        }\n        const lastProblem = problems[problems.length - 1];\n        for (const problem of problems) {\n            if (problem.time > timestamp) {\n                return Object.assign({}, problem, { fixed: lastProblem.fixed });\n            }\n        }\n        if (lastProblem.fixed) {\n            return null;\n        } else {\n            return lastProblem;\n        }\n    }\n\n    public async filterOutNotifiedErrorDevices(devices: IOlmDevice[]): Promise<IOlmDevice[]> {\n        const notifiedErrorDevices = this.notifiedErrorDevices;\n        const ret: IOlmDevice[] = [];\n\n        for (const device of devices) {\n            const { userId, deviceInfo } = device;\n            if (userId in notifiedErrorDevices) {\n                if (!(deviceInfo.deviceId in notifiedErrorDevices[userId])) {\n                    ret.push(device);\n                    safeSet(notifiedErrorDevices[userId], deviceInfo.deviceId, true);\n                }\n            } else {\n                ret.push(device);\n                safeSet(notifiedErrorDevices, userId, { [deviceInfo.deviceId]: true });\n            }\n        }\n\n        return ret;\n    }\n\n    /**\n     * Fetch a batch of Olm sessions from the database.\n     *\n     * Implementation of {@link CryptoStore.getEndToEndSessionsBatch}.\n     *\n     * @internal\n     */\n    public async getEndToEndSessionsBatch(): Promise<null | ISessionInfo[]> {\n        const result: ISessionInfo[] = [];\n        for (const deviceSessions of Object.values(this.sessions)) {\n            for (const session of Object.values(deviceSessions)) {\n                result.push(session);\n                if (result.length >= SESSION_BATCH_SIZE) {\n                    return result;\n                }\n            }\n        }\n\n        if (result.length === 0) {\n            // No sessions left.\n            return null;\n        }\n\n        // There are fewer sessions than the batch size; return the final batch of sessions.\n        return result;\n    }\n\n    /**\n     * Delete a batch of Olm sessions from the database.\n     *\n     * Implementation of {@link CryptoStore.deleteEndToEndSessionsBatch}.\n     *\n     * @internal\n     */\n    public async deleteEndToEndSessionsBatch(sessions: { deviceKey: string; sessionId: string }[]): Promise<void> {\n        for (const { deviceKey, sessionId } of sessions) {\n            const deviceSessions = this.sessions[deviceKey] || {};\n            delete deviceSessions[sessionId];\n            if (Object.keys(deviceSessions).length === 0) {\n                // No more sessions for this device.\n                delete this.sessions[deviceKey];\n            }\n        }\n    }\n\n    // Inbound Group Sessions\n\n    public getEndToEndInboundGroupSession(\n        senderCurve25519Key: string,\n        sessionId: string,\n        txn: unknown,\n        func: (groupSession: InboundGroupSessionData | null, groupSessionWithheld: IWithheld | null) => void,\n    ): void {\n        const k = encodeSessionKey(senderCurve25519Key, sessionId);\n        func(this.inboundGroupSessions[k] || null, this.inboundGroupSessionsWithheld[k] || null);\n    }\n\n    public getAllEndToEndInboundGroupSessions(txn: unknown, func: (session: ISession | null) => void): void {\n        for (const key of Object.keys(this.inboundGroupSessions)) {\n            func({\n                ...decodeSessionKey(key),\n                sessionData: this.inboundGroupSessions[key],\n            });\n        }\n        func(null);\n    }\n\n    public addEndToEndInboundGroupSession(\n        senderCurve25519Key: string,\n        sessionId: string,\n        sessionData: InboundGroupSessionData,\n        txn: unknown,\n    ): void {\n        const k = encodeSessionKey(senderCurve25519Key, sessionId);\n        if (this.inboundGroupSessions[k] === undefined) {\n            this.inboundGroupSessions[k] = sessionData;\n        }\n    }\n\n    public storeEndToEndInboundGroupSession(\n        senderCurve25519Key: string,\n        sessionId: string,\n        sessionData: InboundGroupSessionData,\n        txn: unknown,\n    ): void {\n        const k = encodeSessionKey(senderCurve25519Key, sessionId);\n        this.inboundGroupSessions[k] = sessionData;\n    }\n\n    public storeEndToEndInboundGroupSessionWithheld(\n        senderCurve25519Key: string,\n        sessionId: string,\n        sessionData: IWithheld,\n        txn: unknown,\n    ): void {\n        const k = encodeSessionKey(senderCurve25519Key, sessionId);\n        this.inboundGroupSessionsWithheld[k] = sessionData;\n    }\n\n    /**\n     * Count the number of Megolm sessions in the database.\n     *\n     * Implementation of {@link CryptoStore.countEndToEndInboundGroupSessions}.\n     *\n     * @internal\n     */\n    public async countEndToEndInboundGroupSessions(): Promise<number> {\n        return Object.keys(this.inboundGroupSessions).length;\n    }\n\n    /**\n     * Fetch a batch of Megolm sessions from the database.\n     *\n     * Implementation of {@link CryptoStore.getEndToEndInboundGroupSessionsBatch}.\n     *\n     * @internal\n     */\n    public async getEndToEndInboundGroupSessionsBatch(): Promise<null | SessionExtended[]> {\n        const result: SessionExtended[] = [];\n        for (const [key, session] of Object.entries(this.inboundGroupSessions)) {\n            result.push({\n                ...decodeSessionKey(key),\n                sessionData: session,\n                needsBackup: key in this.sessionsNeedingBackup,\n            });\n            if (result.length >= SESSION_BATCH_SIZE) {\n                return result;\n            }\n        }\n\n        if (result.length === 0) {\n            // No sessions left.\n            return null;\n        }\n\n        // There are fewer sessions than the batch size; return the final batch of sessions.\n        return result;\n    }\n\n    /**\n     * Delete a batch of Megolm sessions from the database.\n     *\n     * Implementation of {@link CryptoStore.deleteEndToEndInboundGroupSessionsBatch}.\n     *\n     * @internal\n     */\n    public async deleteEndToEndInboundGroupSessionsBatch(\n        sessions: { senderKey: string; sessionId: string }[],\n    ): Promise<void> {\n        for (const { senderKey, sessionId } of sessions) {\n            const k = encodeSessionKey(senderKey, sessionId);\n            delete this.inboundGroupSessions[k];\n        }\n    }\n\n    // Device Data\n\n    public getEndToEndDeviceData(txn: unknown, func: (deviceData: IDeviceData | null) => void): void {\n        func(this.deviceData);\n    }\n\n    public storeEndToEndDeviceData(deviceData: IDeviceData, txn: unknown): void {\n        this.deviceData = deviceData;\n    }\n\n    // E2E rooms\n\n    public storeEndToEndRoom(roomId: string, roomInfo: IRoomEncryption, txn: unknown): void {\n        this.rooms[roomId] = roomInfo;\n    }\n\n    public getEndToEndRooms(txn: unknown, func: (rooms: Record<string, IRoomEncryption>) => void): void {\n        func(this.rooms);\n    }\n\n    public getSessionsNeedingBackup(limit: number): Promise<ISession[]> {\n        const sessions: ISession[] = [];\n        for (const session in this.sessionsNeedingBackup) {\n            if (this.inboundGroupSessions[session]) {\n                sessions.push({\n                    ...decodeSessionKey(session),\n                    sessionData: this.inboundGroupSessions[session],\n                });\n                if (limit && session.length >= limit) {\n                    break;\n                }\n            }\n        }\n        return Promise.resolve(sessions);\n    }\n\n    public countSessionsNeedingBackup(): Promise<number> {\n        return Promise.resolve(Object.keys(this.sessionsNeedingBackup).length);\n    }\n\n    public unmarkSessionsNeedingBackup(sessions: ISession[]): Promise<void> {\n        for (const session of sessions) {\n            const sessionKey = encodeSessionKey(session.senderKey, session.sessionId);\n            delete this.sessionsNeedingBackup[sessionKey];\n        }\n        return Promise.resolve();\n    }\n\n    public markSessionsNeedingBackup(sessions: ISession[]): Promise<void> {\n        for (const session of sessions) {\n            const sessionKey = encodeSessionKey(session.senderKey, session.sessionId);\n            this.sessionsNeedingBackup[sessionKey] = true;\n        }\n        return Promise.resolve();\n    }\n\n    public addSharedHistoryInboundGroupSession(roomId: string, senderKey: string, sessionId: string): void {\n        const sessions = this.sharedHistoryInboundGroupSessions[roomId] || [];\n        sessions.push([senderKey, sessionId]);\n        this.sharedHistoryInboundGroupSessions[roomId] = sessions;\n    }\n\n    public getSharedHistoryInboundGroupSessions(roomId: string): Promise<[senderKey: string, sessionId: string][]> {\n        return Promise.resolve(this.sharedHistoryInboundGroupSessions[roomId] || []);\n    }\n\n    public addParkedSharedHistory(roomId: string, parkedData: ParkedSharedHistory): void {\n        const parked = this.parkedSharedHistory.get(roomId) ?? [];\n        parked.push(parkedData);\n        this.parkedSharedHistory.set(roomId, parked);\n    }\n\n    public takeParkedSharedHistory(roomId: string): Promise<ParkedSharedHistory[]> {\n        const parked = this.parkedSharedHistory.get(roomId) ?? [];\n        this.parkedSharedHistory.delete(roomId);\n        return Promise.resolve(parked);\n    }\n\n    // Session key backups\n\n    public doTxn<T>(mode: Mode, stores: Iterable<string>, func: (txn?: unknown) => T): Promise<T> {\n        return Promise.resolve(func(null));\n    }\n}\n"],"mappings":"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","ignoreList":[]}