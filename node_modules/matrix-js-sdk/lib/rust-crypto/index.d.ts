import { RustCrypto } from "./rust-crypto";
import { IHttpOpts, MatrixHttpApi } from "../http-api";
import { ServerSideSecretStorage } from "../secret-storage";
import { ICryptoCallbacks } from "../crypto";
import { Logger } from "../logger";
import { CryptoStore } from "../crypto/store/base";
/**
 * Create a new `RustCrypto` implementation
 *
 * @param args - Parameter object
 * @internal
 */
export declare function initRustCrypto(args: {
    /** A `Logger` instance that will be used for debug output. */
    logger: Logger;
    /**
     * Low-level HTTP interface: used to make outgoing requests required by the rust SDK.
     * We expect it to set the access token, etc.
     */
    http: MatrixHttpApi<IHttpOpts & {
        onlyData: true;
    }>;
    /** The local user's User ID. */
    userId: string;
    /** The local user's Device ID. */
    deviceId: string;
    /** Interface to server-side secret storage. */
    secretStorage: ServerSideSecretStorage;
    /** Crypto callbacks provided by the application. */
    cryptoCallbacks: ICryptoCallbacks;
    /**
     * The prefix to use on the indexeddbs created by rust-crypto.
     * If `null`, a memory store will be used.
     */
    storePrefix: string | null;
    /**
     * A passphrase to use to encrypt the indexeddbs created by rust-crypto.
     *
     * Ignored if `storePrefix` is null. If this is `undefined` (and `storePrefix` is not null), the indexeddbs
     * will be unencrypted.
     */
    storePassphrase?: string;
    /** If defined, we will check if any data needs migrating from this store to the rust store. */
    legacyCryptoStore?: CryptoStore;
    /** The pickle key for `legacyCryptoStore` */
    legacyPickleKey?: string;
    /**
     * A callback which will receive progress updates on migration from `legacyCryptoStore`.
     *
     * Called with (-1, -1) to mark the end of migration.
     */
    legacyMigrationProgressListener?: (progress: number, total: number) => void;
}): Promise<RustCrypto>;
//# sourceMappingURL=index.d.ts.map