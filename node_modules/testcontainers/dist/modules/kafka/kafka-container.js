"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StartedKafkaContainer = exports.KafkaContainer = exports.KAFKA_IMAGE = void 0;
const generic_container_1 = require("../../generic-container/generic-container");
const uuid_1 = require("../../uuid");
const abstract_started_container_1 = require("../abstract-started-container");
const KAFKA_PORT = 9093;
const KAFKA_BROKER_PORT = 9092;
const DEFAULT_ZOOKEEPER_PORT = 2181;
exports.KAFKA_IMAGE = "confluentinc/cp-kafka:5.5.4";
class KafkaContainer extends generic_container_1.GenericContainer {
    constructor(image = exports.KAFKA_IMAGE) {
        super(image);
        this.uuid = new uuid_1.RandomUuid();
        this.isZooKeeperProvided = false;
        this.withExposedPorts(KAFKA_PORT)
            .withStartupTimeout(180000)
            .withEnv("KAFKA_LISTENER_SECURITY_PROTOCOL_MAP", "BROKER:PLAINTEXT,PLAINTEXT:PLAINTEXT")
            .withEnv("KAFKA_INTER_BROKER_LISTENER_NAME", "BROKER")
            .withEnv("KAFKA_BROKER_ID", "1")
            .withEnv("KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR", "1")
            .withEnv("KAFKA_OFFSETS_TOPIC_NUM_PARTITIONS", "1")
            .withEnv("KAFKA_TRANSACTION_STATE_LOG_MIN_ISR", "1")
            .withEnv("KAFKA_LOG_FLUSH_INTERVAL_MESSAGES", "9223372036854775807")
            .withEnv("KAFKA_GROUP_INITIAL_REBALANCE_DELAY_MS", "0")
            .withEnv("KAFKA_CONFLUENT_SUPPORT_METRICS_ENABLE", "false");
    }
    withZooKeeper(host, port) {
        this.isZooKeeperProvided = true;
        this.zooKeeperHost = host;
        this.zooKeeperPort = port;
        return this;
    }
    withSaslSslListener(options) {
        this.saslSslConfig = options;
        return this;
    }
    preStart() {
        return __awaiter(this, void 0, void 0, function* () {
            const network = this.networkMode && this.networkAliases.length > 0 ? this.networkAliases[0] : "localhost";
            this.withEnv("KAFKA_ADVERTISED_LISTENERS", `BROKER://${network}:${KAFKA_BROKER_PORT}`);
            if (this.saslSslConfig) {
                this.addPlaintextAndSecureListener(this.saslSslConfig);
            }
            else {
                this.addPlaintextListener();
            }
            let command = "#!/bin/bash\n";
            if (this.isZooKeeperProvided) {
                this.withEnv("KAFKA_ZOOKEEPER_CONNECT", `${this.zooKeeperHost}:${this.zooKeeperPort}`);
            }
            else {
                this.zooKeeperHost = this.uuid.nextUuid();
                this.zooKeeperPort = DEFAULT_ZOOKEEPER_PORT;
                this.addExposedPorts(this.zooKeeperPort);
                this.withEnv("KAFKA_ZOOKEEPER_CONNECT", `localhost:${this.zooKeeperPort}`);
                command += "echo 'clientPort=" + this.zooKeeperPort + "' > zookeeper.properties\n";
                command += "echo 'dataDir=/var/lib/zookeeper/data' >> zookeeper.properties\n";
                command += "echo 'dataLogDir=/var/lib/zookeeper/log' >> zookeeper.properties\n";
                command += "zookeeper-server-start zookeeper.properties &\n";
            }
            command += "echo '' > /etc/confluent/docker/ensure \n";
            command += "/etc/confluent/docker/run \n";
            this.withCmd(["sh", "-c", command]);
        });
    }
    start() {
        const _super = Object.create(null, {
            start: { get: () => super.start }
        });
        return __awaiter(this, void 0, void 0, function* () {
            return new StartedKafkaContainer(yield _super.start.call(this));
        });
    }
    postStart(container, inspectResult, boundPorts) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.updateAdvertisedListeners(container, inspectResult, boundPorts);
            if (this.saslSslConfig) {
                yield this.createUser(container, this.saslSslConfig.sasl);
            }
        });
    }
    addPlaintextAndSecureListener({ port, sasl, keystore, truststore }) {
        this.withEnv("KAFKA_LISTENERS", `SECURE://0.0.0.0:${port},PLAINTEXT://0.0.0.0:${KAFKA_PORT},BROKER://0.0.0.0:${KAFKA_BROKER_PORT}`)
            .withEnv("KAFKA_LISTENER_SECURITY_PROTOCOL_MAP", "BROKER:PLAINTEXT,PLAINTEXT:PLAINTEXT,SECURE:SASL_SSL")
            .withEnv("KAFKA_SSL_PROTOCOL", "TLSv1.2")
            .withCopyContentToContainer(keystore.content, "/etc/kafka/secrets/server.keystore.pfx")
            .withEnv("KAFKA_SSL_KEYSTORE_LOCATION", "/etc/kafka/secrets/server.keystore.pfx")
            .withEnv("KAFKA_SSL_KEYSTORE_PASSWORD", keystore.passphrase)
            .withEnv("KAFKA_SSL_KEYSTORE_TYPE", "PKCS12")
            .withEnv("KAFKA_SASL_ENABLED_MECHANISMS", sasl.mechanism)
            .withEnv(`KAFKA_LISTENER_NAME_SECURE_${sasl.mechanism}_SASL_JAAS_CONFIG`, "org.apache.kafka.common.security.scram.ScramLoginModule required;")
            .addExposedPorts(KAFKA_PORT, port);
        if (truststore) {
            this.withCopyContentToContainer(truststore.content, "/etc/kafka/secrets/server.truststore.pfx")
                .withEnv("KAFKA_SSL_TRUSTSTORE_LOCATION", "/etc/kafka/secrets/server.truststore.pfx")
                .withEnv("KAFKA_SSL_TRUSTSTORE_PASSWORD", truststore.passphrase)
                .withEnv("KAFKA_SSL_TRUSTSTORE_TYPE", "PKCS12");
        }
    }
    addPlaintextListener() {
        this.withEnv("KAFKA_LISTENERS", `PLAINTEXT://0.0.0.0:${KAFKA_PORT},BROKER://0.0.0.0:${KAFKA_BROKER_PORT}`).addExposedPorts(KAFKA_PORT);
    }
    updateAdvertisedListeners(container, inspectResult, boundPorts) {
        return __awaiter(this, void 0, void 0, function* () {
            const brokerAdvertisedListener = `BROKER://${inspectResult.hostname}:${KAFKA_BROKER_PORT}`;
            let bootstrapServers = `PLAINTEXT://${container.getHost()}:${boundPorts.getBinding(KAFKA_PORT)}`;
            if (this.saslSslConfig) {
                bootstrapServers = `${bootstrapServers},SECURE://${container.getHost()}:${boundPorts.getBinding(this.saslSslConfig.port)}`;
            }
            const { output, exitCode } = yield container.exec([
                "kafka-configs",
                "--alter",
                "--bootstrap-server",
                brokerAdvertisedListener,
                "--entity-type",
                "brokers",
                "--entity-name",
                this.env["KAFKA_BROKER_ID"],
                "--add-config",
                `advertised.listeners=[${bootstrapServers},${brokerAdvertisedListener}]`,
            ]);
            if (exitCode !== 0) {
                throw new Error(`Kafka container configuration failed with exit code ${exitCode}: ${output}`);
            }
        });
    }
    createUser(container, { user: { name, password }, mechanism }) {
        return __awaiter(this, void 0, void 0, function* () {
            const { output, exitCode } = yield container.exec([
                "kafka-configs",
                "--alter",
                // At the time of writing kafka-configs displays a warning stating that the 'zookeeper' flag is deprecated in favor of 'bootstrap-server'.
                // Unfortunately, 'bootstrap-server' can only be used to set quotas and not to create a user.
                "--zookeeper",
                this.env["KAFKA_ZOOKEEPER_CONNECT"],
                "--entity-type",
                "users",
                "--entity-name",
                `${name}`,
                "--add-config",
                `${mechanism}=[password=${password}]`,
            ]);
            if (exitCode !== 0) {
                throw new Error(`Kafka container configuration failed with exit code ${exitCode}: ${output}`);
            }
        });
    }
}
exports.KafkaContainer = KafkaContainer;
class StartedKafkaContainer extends abstract_started_container_1.AbstractStartedContainer {
    constructor(startedTestContainer) {
        super(startedTestContainer);
    }
}
exports.StartedKafkaContainer = StartedKafkaContainer;
