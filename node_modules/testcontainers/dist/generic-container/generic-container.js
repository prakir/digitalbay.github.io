"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GenericContainer = void 0;
const archiver_1 = __importDefault(require("archiver"));
const bound_ports_1 = require("../bound-ports");
const logger_1 = require("../logger");
const port_check_1 = require("../port-check");
const pull_policy_1 = require("../pull-policy");
const reaper_1 = require("../reaper");
const docker_image_name_1 = require("../docker-image-name");
const wait_strategy_1 = require("../wait-strategy");
const port_forwarder_1 = require("../port-forwarder");
const registry_auth_locator_1 = require("../registry-auth-locator");
const pull_image_1 = require("../docker/functions/image/pull-image");
const create_container_1 = require("../docker/functions/container/create-container");
const connect_network_1 = require("../docker/functions/network/connect-network");
const docker_client_1 = require("../docker/docker-client");
const inspect_container_1 = require("../docker/functions/container/inspect-container");
const start_container_1 = require("../docker/functions/container/start-container");
const container_logs_1 = require("../docker/functions/container/container-logs");
const stop_container_1 = require("../docker/functions/container/stop-container");
const remove_container_1 = require("../docker/functions/container/remove-container");
const put_container_archive_1 = require("../docker/functions/container/put-container-archive");
const generic_container_builder_1 = require("./generic-container-builder");
const started_generic_container_1 = require("./started-generic-container");
const hash_1 = require("../hash");
const get_container_1 = require("../docker/functions/container/get-container");
const labels_1 = require("../labels");
class GenericContainer {
    constructor(image) {
        this.image = image;
        this.env = {};
        this.networkAliases = [];
        this.ports = [];
        this.cmd = [];
        this.bindMounts = [];
        this.labels = {};
        this.tmpFs = {};
        this.startupTimeout = 60000;
        this.useDefaultLogDriver = false;
        this.privilegedMode = false;
        this.pullPolicy = new pull_policy_1.DefaultPullPolicy();
        this.reuse = false;
        this.extraHosts = [];
        this.imageName = docker_image_name_1.DockerImageName.fromString(image);
    }
    static fromDockerfile(context, dockerfileName = "Dockerfile") {
        return new generic_container_builder_1.GenericContainerBuilder(context, dockerfileName);
    }
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, pull_image_1.pullImage)((yield (0, docker_client_1.dockerClient)()).dockerode, {
                imageName: this.imageName,
                force: this.pullPolicy.shouldPull(),
                authConfig: yield (0, registry_auth_locator_1.getAuthConfig)(this.imageName.registry),
            });
            if (!this.imageName.isReaper()) {
                yield reaper_1.ReaperInstance.getInstance();
            }
            if (this.preStart) {
                yield this.preStart();
            }
            if (!this.imageName.isHelperContainer() && port_forwarder_1.PortForwarderInstance.isRunning()) {
                const portForwarder = yield port_forwarder_1.PortForwarderInstance.getInstance();
                this.extraHosts.push({ host: "host.testcontainers.internal", ipAddress: portForwarder.getIpAddress() });
            }
            const createContainerOptions = {
                imageName: this.imageName,
                env: this.env,
                cmd: this.cmd,
                entrypoint: this.entrypoint,
                bindMounts: this.bindMounts,
                tmpFs: this.tmpFs,
                exposedPorts: this.ports,
                name: this.name,
                labels: this.labels,
                reusable: this.reuse,
                networkMode: this.networkAliases.length > 0 ? undefined : this.networkMode,
                healthCheck: this.healthCheck,
                useDefaultLogDriver: this.useDefaultLogDriver,
                privilegedMode: this.privilegedMode,
                autoRemove: this.imageName.isReaper(),
                extraHosts: this.extraHosts,
                ipcMode: this.ipcMode,
                ulimits: this.ulimits,
                addedCapabilities: this.addedCapabilities,
                droppedCapabilities: this.droppedCapabilities,
                user: this.user,
            };
            if (this.reuse) {
                const containerHash = (0, hash_1.hash)(JSON.stringify(createContainerOptions));
                createContainerOptions.labels = { [labels_1.LABEL_CONTAINER_HASH]: containerHash };
                logger_1.log.debug(`Container reuse has been enabled, hash: ${containerHash}`);
                const container = yield (0, get_container_1.getContainerByHash)(containerHash);
                if (container !== undefined) {
                    logger_1.log.debug(`Found container to reuse with hash: ${containerHash}`);
                    return this.reuseContainer(container);
                }
                else {
                    logger_1.log.debug("No container found to reuse");
                    return this.startContainer(createContainerOptions);
                }
            }
            else {
                return this.startContainer(createContainerOptions);
            }
        });
    }
    reuseContainer(startedContainer) {
        return __awaiter(this, void 0, void 0, function* () {
            const inspectResult = yield (0, inspect_container_1.inspectContainer)(startedContainer);
            const boundPorts = bound_ports_1.BoundPorts.fromInspectResult(inspectResult).filter(this.ports);
            yield this.waitForContainer(startedContainer, boundPorts);
            return new started_generic_container_1.StartedGenericContainer(startedContainer, (yield (0, docker_client_1.dockerClient)()).host, inspectResult, boundPorts, inspectResult.name, this.getWaitStrategy((yield (0, docker_client_1.dockerClient)()).host, startedContainer).withStartupTimeout(this.startupTimeout));
        });
    }
    startContainer(createContainerOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const container = yield (0, create_container_1.createContainer)(createContainerOptions);
            if (!this.imageName.isHelperContainer() && port_forwarder_1.PortForwarderInstance.isRunning()) {
                const portForwarder = yield port_forwarder_1.PortForwarderInstance.getInstance();
                const portForwarderNetworkId = portForwarder.getNetworkId();
                const excludedNetworks = [portForwarderNetworkId, "none", "host"];
                if (!this.networkMode || !excludedNetworks.includes(this.networkMode)) {
                    yield (0, connect_network_1.connectNetwork)({
                        containerId: container.id,
                        networkId: portForwarderNetworkId,
                        networkAliases: [],
                    });
                }
            }
            if (this.networkMode && this.networkAliases.length > 0) {
                yield (0, connect_network_1.connectNetwork)({
                    containerId: container.id,
                    networkId: this.networkMode,
                    networkAliases: this.networkAliases,
                });
            }
            if (this.tarToCopy) {
                this.tarToCopy.finalize();
                yield (0, put_container_archive_1.putContainerArchive)({ container, stream: this.tarToCopy, containerPath: "/" });
            }
            logger_1.log.info(`Starting container ${this.imageName} with ID: ${container.id}`);
            yield (0, start_container_1.startContainer)(container);
            (yield (0, container_logs_1.containerLogs)(container))
                .on("data", (data) => logger_1.containerLog.trace(`${container.id}: ${data.trim()}`))
                .on("err", (data) => logger_1.containerLog.error(`${container.id}: ${data.trim()}`));
            const inspectResult = yield (0, inspect_container_1.inspectContainer)(container);
            const boundPorts = bound_ports_1.BoundPorts.fromInspectResult(inspectResult).filter(this.ports);
            yield this.waitForContainer(container, boundPorts);
            const startedContainer = new started_generic_container_1.StartedGenericContainer(container, (yield (0, docker_client_1.dockerClient)()).host, inspectResult, boundPorts, inspectResult.name, this.getWaitStrategy((yield (0, docker_client_1.dockerClient)()).host, container).withStartupTimeout(this.startupTimeout));
            if (this.postStart) {
                yield this.postStart(startedContainer, inspectResult, boundPorts);
            }
            return startedContainer;
        });
    }
    get hasExposedPorts() {
        return this.ports.length !== 0;
    }
    withCmd(cmd) {
        this.cmd = cmd;
        return this;
    }
    withEntrypoint(entrypoint) {
        this.entrypoint = entrypoint;
        return this;
    }
    withName(name) {
        this.name = name;
        return this;
    }
    withLabels(labels) {
        this.labels = Object.assign({}, labels);
        return this;
    }
    withEnv(key, value) {
        this.env[key] = value;
        return this;
    }
    withTmpFs(tmpFs) {
        this.tmpFs = tmpFs;
        return this;
    }
    withUlimits(ulimits) {
        this.ulimits = ulimits;
        return this;
    }
    withAddedCapabilities(...capabilities) {
        this.addedCapabilities = capabilities;
        return this;
    }
    withDroppedCapabilities(...capabilities) {
        this.droppedCapabilities = capabilities;
        return this;
    }
    withNetworkMode(networkMode) {
        this.networkMode = networkMode;
        return this;
    }
    withNetworkAliases(...networkAliases) {
        this.networkAliases = networkAliases;
        return this;
    }
    withExtraHosts(...extraHosts) {
        this.extraHosts.push(...extraHosts);
        return this;
    }
    withExposedPorts(...ports) {
        this.ports = ports;
        return this;
    }
    addExposedPorts(...ports) {
        this.ports.push(...ports);
        return this;
    }
    withBindMount(source, target, bindMode = "rw") {
        this.bindMounts.push({ source, target, bindMode });
        return this;
    }
    withHealthCheck(healthCheck) {
        this.healthCheck = healthCheck;
        return this;
    }
    withStartupTimeout(startupTimeout) {
        this.startupTimeout = startupTimeout;
        return this;
    }
    withWaitStrategy(waitStrategy) {
        this.waitStrategy = waitStrategy;
        return this;
    }
    withDefaultLogDriver() {
        this.useDefaultLogDriver = true;
        return this;
    }
    withPrivilegedMode() {
        this.privilegedMode = true;
        return this;
    }
    withUser(user) {
        this.user = user;
        return this;
    }
    withReuse() {
        this.reuse = true;
        return this;
    }
    withPullPolicy(pullPolicy) {
        this.pullPolicy = pullPolicy;
        return this;
    }
    withIpcMode(ipcMode) {
        this.ipcMode = ipcMode;
        return this;
    }
    withCopyFileToContainer(sourcePath, containerPath) {
        this.getTarToCopy().file(sourcePath, { name: containerPath });
        return this;
    }
    withCopyContentToContainer(content, containerPath) {
        this.getTarToCopy().append(content, { name: containerPath });
        return this;
    }
    getTarToCopy() {
        if (!this.tarToCopy) {
            this.tarToCopy = (0, archiver_1.default)("tar");
        }
        return this.tarToCopy;
    }
    waitForContainer(container, boundPorts) {
        return __awaiter(this, void 0, void 0, function* () {
            logger_1.log.debug(`Waiting for container to be ready: ${container.id}`);
            const waitStrategy = this.getWaitStrategy((yield (0, docker_client_1.dockerClient)()).host, container);
            try {
                yield waitStrategy.withStartupTimeout(this.startupTimeout).waitUntilReady(container, boundPorts);
                logger_1.log.info("Container is ready");
            }
            catch (err) {
                logger_1.log.error(`Container failed to be ready: ${err}`);
                try {
                    yield (0, stop_container_1.stopContainer)(container, { timeout: 0 });
                    yield (0, remove_container_1.removeContainer)(container, { removeVolumes: true });
                }
                catch (stopErr) {
                    logger_1.log.error(`Failed to stop container after it failed to be ready: ${stopErr}`);
                }
                throw err;
            }
        });
    }
    getWaitStrategy(host, container) {
        if (this.waitStrategy) {
            return this.waitStrategy;
        }
        const hostPortCheck = new port_check_1.HostPortCheck(host);
        const internalPortCheck = new port_check_1.InternalPortCheck(container);
        return new wait_strategy_1.HostPortWaitStrategy(hostPortCheck, internalPortCheck);
    }
}
exports.GenericContainer = GenericContainer;
