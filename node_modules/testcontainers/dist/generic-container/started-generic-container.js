"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StartedGenericContainer = void 0;
const inspect_container_1 = require("../docker/functions/container/inspect-container");
const bound_ports_1 = require("../bound-ports");
const logger_1 = require("../logger");
const remove_container_1 = require("../docker/functions/container/remove-container");
const exec_container_1 = require("../docker/functions/container/exec-container");
const container_logs_1 = require("../docker/functions/container/container-logs");
const stopped_generic_container_1 = require("./stopped-generic-container");
const stop_container_1 = require("../docker/functions/container/stop-container");
const restart_container_1 = require("../docker/functions/container/restart-container");
class StartedGenericContainer {
    constructor(container, host, inspectResult, boundPorts, name, waitStrategy) {
        this.container = container;
        this.host = host;
        this.inspectResult = inspectResult;
        this.boundPorts = boundPorts;
        this.name = name;
        this.waitStrategy = waitStrategy;
    }
    stop(options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.stopContainer(options);
        });
    }
    restart(options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const resolvedOptions = Object.assign({ timeout: 0 }, options);
            yield (0, restart_container_1.restartContainer)(this.container, resolvedOptions);
            this.inspectResult = yield (0, inspect_container_1.inspectContainer)(this.container);
            this.boundPorts = bound_ports_1.BoundPorts.fromInspectResult(this.inspectResult).filter(Array.from(this.boundPorts.iterator()).map((port) => port[0]));
            yield this.waitForContainer(this.container, this.boundPorts);
        });
    }
    stopContainer(options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            logger_1.log.info(`Stopping container with ID: ${this.container.id}`);
            const resolvedOptions = Object.assign({ timeout: 0, removeVolumes: true }, options);
            yield (0, stop_container_1.stopContainer)(this.container, { timeout: resolvedOptions.timeout });
            yield (0, remove_container_1.removeContainer)(this.container, { removeVolumes: resolvedOptions.removeVolumes });
            return new stopped_generic_container_1.StoppedGenericContainer();
        });
    }
    waitForContainer(container, boundPorts) {
        return __awaiter(this, void 0, void 0, function* () {
            logger_1.log.debug(`Waiting for container to be ready: ${container.id}`);
            try {
                yield this.waitStrategy.waitUntilReady(container, boundPorts);
                logger_1.log.info("Container is ready");
            }
            catch (err) {
                logger_1.log.error(`Container failed to be ready: ${err}`);
                try {
                    yield (0, stop_container_1.stopContainer)(container, { timeout: 0 });
                    yield (0, remove_container_1.removeContainer)(container, { removeVolumes: true });
                }
                catch (stopErr) {
                    logger_1.log.error(`Failed to stop container after it failed to be ready: ${stopErr}`);
                }
                throw err;
            }
        });
    }
    getHost() {
        return this.host;
    }
    getMappedPort(port) {
        return this.boundPorts.getBinding(port);
    }
    getId() {
        return this.container.id;
    }
    getName() {
        return this.name;
    }
    getLabels() {
        return this.inspectResult.labels;
    }
    getNetworkNames() {
        return Object.keys(this.inspectResult.networkSettings);
    }
    getNetworkId(networkName) {
        return this.inspectResult.networkSettings[networkName].networkId;
    }
    getIpAddress(networkName) {
        return this.inspectResult.networkSettings[networkName].ipAddress;
    }
    exec(command, options = {}) {
        const resolvedOptions = Object.assign({ stdin: true, detach: false, tty: true }, options);
        return (0, exec_container_1.execContainer)(this.container, command, resolvedOptions);
    }
    logs() {
        return (0, container_logs_1.containerLogs)(this.container);
    }
}
exports.StartedGenericContainer = StartedGenericContainer;
