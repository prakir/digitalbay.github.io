"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.InternalPortCheck = exports.HostPortCheck = void 0;
const net_1 = require("net");
const exec_container_1 = require("./docker/functions/container/exec-container");
const logger_1 = require("./logger");
class HostPortCheck {
    constructor(host) {
        this.host = host;
    }
    isBound(port) {
        return new Promise((resolve) => {
            const socket = new net_1.Socket();
            socket
                .setTimeout(1000)
                .on("error", () => {
                socket.destroy();
                resolve(false);
            })
                .on("timeout", () => {
                socket.destroy();
                resolve(false);
            })
                .connect(port, this.host, () => {
                socket.end();
                resolve(true);
            });
        });
    }
}
exports.HostPortCheck = HostPortCheck;
class InternalPortCheck {
    constructor(container) {
        this.container = container;
        this.isDistroless = false;
        this.commandOutputs = new Set();
    }
    isBound(port) {
        return __awaiter(this, void 0, void 0, function* () {
            const portHex = port.toString(16).padStart(4, "0");
            const commands = [
                ["/bin/sh", "-c", `cat /proc/net/tcp* | awk '{print $2}' | grep -i :${portHex}`],
                ["/bin/sh", "-c", `nc -vz -w 1 localhost ${port}`],
                ["/bin/bash", "-c", `</dev/tcp/localhost/${port}`],
            ];
            const commandResults = yield Promise.all(commands.map((command) => (0, exec_container_1.execContainer)(this.container, command, { stdin: true, detach: false, tty: true }, false)));
            const isBound = commandResults.some((result) => result.exitCode === 0);
            if (!isBound) {
                const shellExists = commandResults.some((result) => result.exitCode !== 126);
                if (!shellExists) {
                    if (!this.isDistroless) {
                        this.isDistroless = true;
                        logger_1.log.error(`The HostPortWaitStrategy will not work on a distroless image, use an alternate wait strategy for container ${this.container.id}`);
                    }
                }
                else {
                    commandResults
                        .map((result) => (Object.assign(Object.assign({}, result), { output: result.output.trim() })))
                        .filter((result) => result.exitCode !== 126 && result.output.length > 0)
                        .forEach((result) => {
                        if (!this.commandOutputs.has(this.commandOutputsKey(result.output))) {
                            logger_1.log.trace(`Port check result for container ${this.container.id} exit code ${result.exitCode}: ${result.output}`);
                            this.commandOutputs.add(this.commandOutputsKey(result.output));
                        }
                    });
                }
            }
            return isBound;
        });
    }
    commandOutputsKey(output) {
        return `${this.container.id}:${output}`;
    }
}
exports.InternalPortCheck = InternalPortCheck;
