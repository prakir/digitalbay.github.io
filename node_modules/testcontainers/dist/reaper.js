"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReaperInstance = void 0;
const net_1 = require("net");
const logger_1 = require("./logger");
const generic_container_1 = require("./generic-container/generic-container");
const session_id_1 = require("./docker/session-id");
const images_1 = require("./images");
const port_1 = require("./port");
const labels_1 = require("./labels");
const wait_1 = require("./wait");
class RealReaper {
    constructor(container, socket) {
        this.container = container;
        this.socket = socket;
    }
    addProject(projectName) {
        this.socket.write(`label=com.docker.compose.project=${projectName}\r\n`);
    }
    getContainerId() {
        return this.container.getId();
    }
    stop() {
        this.socket.end();
    }
}
class DisabledReaper {
    addProject() {
        // noop
    }
    stop() {
        // noop
    }
    getContainerId() {
        return "";
    }
}
class ReaperInstance {
    static getInstance() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.instance) {
                if (this.isEnabled()) {
                    this.instance = this.createRealInstance();
                }
                else {
                    this.instance = this.createDisabledInstance();
                }
            }
            return this.instance;
        });
    }
    static stopInstance() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.instance) {
                const reaper = yield this.instance;
                reaper.stop();
                this.instance = undefined;
            }
        });
    }
    static isEnabled() {
        return process.env.TESTCONTAINERS_RYUK_DISABLED !== "true";
    }
    static isPrivileged() {
        return process.env.TESTCONTAINERS_RYUK_PRIVILEGED === "true";
    }
    static createDisabledInstance() {
        logger_1.log.debug(`Not creating new Reaper for session: ${session_id_1.sessionId}`);
        return Promise.resolve(new DisabledReaper());
    }
    static createRealInstance() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const dockerSocket = (_a = process.env["TESTCONTAINERS_DOCKER_SOCKET_OVERRIDE"]) !== null && _a !== void 0 ? _a : "/var/run/docker.sock";
            const containerPort = process.env["TESTCONTAINERS_RYUK_PORT"]
                ? { container: 8080, host: Number(process.env["TESTCONTAINERS_RYUK_PORT"]) }
                : 8080;
            logger_1.log.debug(`Creating new Reaper for session: ${session_id_1.sessionId}`);
            const container = new generic_container_1.GenericContainer(images_1.REAPER_IMAGE)
                .withName(`testcontainers-ryuk-${session_id_1.sessionId}`)
                .withExposedPorts(containerPort)
                .withBindMount(dockerSocket, "/var/run/docker.sock")
                .withWaitStrategy(wait_1.Wait.forLogMessage(/.+ Started!/));
            if (this.isPrivileged()) {
                container.withPrivilegedMode();
            }
            const startedContainer = yield container.start();
            const containerId = startedContainer.getId();
            const host = startedContainer.getHost();
            const port = startedContainer.getMappedPort(8080);
            logger_1.log.debug(`Connecting to Reaper ${containerId} on ${host}:${port}`);
            const socket = new net_1.Socket();
            socket.unref();
            socket
                .on("timeout", () => logger_1.log.error(`Reaper ${containerId} socket timed out`))
                .on("error", (err) => logger_1.log.error(`Reaper ${containerId} socket error: ${err}`))
                .on("close", (hadError) => {
                if (hadError) {
                    logger_1.log.error(`Connection to Reaper ${containerId} closed with error`);
                }
                else {
                    logger_1.log.warn(`Connection to Reaper ${containerId} closed`);
                }
            });
            return new Promise((resolve) => {
                socket.connect((0, port_1.getContainerPort)(port), host, () => {
                    logger_1.log.debug(`Connected to Reaper ${containerId}`);
                    socket.write(`label=${labels_1.LABEL_SESSION_ID}=${session_id_1.sessionId}\r\n`);
                    const reaper = new RealReaper(startedContainer, socket);
                    resolve(reaper);
                });
            });
        });
    }
}
exports.ReaperInstance = ReaperInstance;
